<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>adacad-weaver documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">adacad-weaver documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content miscellaneous-variables">
                   <div class="content-data">


















<ol class="breadcrumb">
  <li>Miscellaneous</li>
  <li>Variables</li>
</ol>

<section>
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <ul class="index-list">
                        <li>
                            <a href="#appendBlankCol" title="src/app/core/model/drafts.ts" ><b>appendBlankCol</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#apply_mats" title="src/app/mixer/model/op_definitions.ts" ><b>apply_mats</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#applyMask" title="src/app/core/model/drafts.ts" ><b>applyMask</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#atop" title="src/app/mixer/model/op_definitions.ts" ><b>atop</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#basket" title="src/app/mixer/model/op_definitions.ts" ><b>basket</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#bindwarpfloats" title="src/app/mixer/model/op_definitions.ts" ><b>bindwarpfloats</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#bindweftfloats" title="src/app/mixer/model/op_definitions.ts" ><b>bindweftfloats</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#CanvasToBMP" title="src/app/core/model/canvas2image.ts" ><b>CanvasToBMP</b>&nbsp;&nbsp;&nbsp;(src/.../canvas2image.ts)</a>
                        </li>
                        <li>
                            <a href="#chaos" title="src/app/mixer/model/op_definitions.ts" ><b>chaos</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#clear" title="src/app/mixer/model/op_definitions.ts" ><b>clear</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#complextwill" title="src/app/mixer/model/op_definitions.ts" ><b>complextwill</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#computeDrawdown" title="src/app/core/model/looms.ts" ><b>computeDrawdown</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#computeYarnPaths" title="src/app/core/model/yarnsimulation.ts" ><b>computeYarnPaths</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#ConstraintName" title="src/app/mixer/model/operation/topology.ts" ><b>ConstraintName</b>&nbsp;&nbsp;&nbsp;(src/.../topology.ts)</a>
                        </li>
                        <li>
                            <a href="#ConstraintOptions" title="src/app/mixer/model/operation/topology.ts" ><b>ConstraintOptions</b>&nbsp;&nbsp;&nbsp;(src/.../topology.ts)</a>
                        </li>
                        <li>
                            <a href="#createBlankDrawdown" title="src/app/core/model/drafts.ts" ><b>createBlankDrawdown</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#createDraft" title="src/app/core/model/drafts.ts" ><b>createDraft</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#crop" title="src/app/mixer/model/op_definitions.ts" ><b>crop</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#defaultPerform" title="src/app/player/model/playerop.ts" ><b>defaultPerform</b>&nbsp;&nbsp;&nbsp;(src/.../playerop.ts)</a>
                        </li>
                        <li>
                            <a href="#deleteDrawdownCol" title="src/app/core/model/drafts.ts" ><b>deleteDrawdownCol</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#deleteDrawdownRow" title="src/app/core/model/drafts.ts" ><b>deleteDrawdownRow</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#deleteMappingCol" title="src/app/core/model/drafts.ts" ><b>deleteMappingCol</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#deleteMappingRow" title="src/app/core/model/drafts.ts" ><b>deleteMappingRow</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#direct_utils" title="src/app/core/model/looms.ts" ><b>direct_utils</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#DraftToWIF" title="src/app/core/model/draft2wif.ts" ><b>DraftToWIF</b>&nbsp;&nbsp;&nbsp;(src/.../draft2wif.ts)</a>
                        </li>
                        <li>
                            <a href="#EMPTY_NODE_ARRAY" title="src/app/player/model/dbnodes.ts" ><b>EMPTY_NODE_ARRAY</b>&nbsp;&nbsp;&nbsp;(src/.../dbnodes.ts)</a>
                        </li>
                        <li>
                            <a href="#erase_blank" title="src/app/mixer/model/op_definitions.ts" ><b>erase_blank</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#fill" title="src/app/mixer/model/op_definitions.ts" ><b>fill</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#flipAndComputeDrawdown" title="src/app/core/model/looms.ts" ><b>flipAndComputeDrawdown</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#flipDraft" title="src/app/core/model/drafts.ts" ><b>flipDraft</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#flipDrawdown" title="src/app/core/model/drafts.ts" ><b>flipDrawdown</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#flipLoom" title="src/app/core/model/looms.ts" ><b>flipLoom</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#flipPattern" title="src/app/core/model/looms.ts" ><b>flipPattern</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#flipThreading" title="src/app/core/model/looms.ts" ><b>flipThreading</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#flipTieUp" title="src/app/core/model/looms.ts" ><b>flipTieUp</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#flipTreadling" title="src/app/core/model/looms.ts" ><b>flipTreadling</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#flipx" title="src/app/mixer/model/op_definitions.ts" ><b>flipx</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#flipy" title="src/app/mixer/model/op_definitions.ts" ><b>flipy</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#forward" title="src/app/player/model/playerop.ts" ><b>forward</b>&nbsp;&nbsp;&nbsp;(src/.../playerop.ts)</a>
                        </li>
                        <li>
                            <a href="#frame_utils" title="src/app/core/model/looms.ts" ><b>frame_utils</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#generateDirectTieup" title="src/app/core/model/looms.ts" ><b>generateDirectTieup</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#generateMappingFromPattern" title="src/app/core/model/drafts.ts" ><b>generateMappingFromPattern</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#generateThreading" title="src/app/core/model/looms.ts" ><b>generateThreading</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#generateTreadlingforFrameLoom" title="src/app/core/model/looms.ts" ><b>generateTreadlingforFrameLoom</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#getDirection" title="src/app/core/model/yarnsimulation.ts" ><b>getDirection</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#getDraftName" title="src/app/core/model/drafts.ts" ><b>getDraftName</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#getHeddle" title="src/app/core/model/drafts.ts" ><b>getHeddle</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#getLoomUtilByType" title="src/app/core/model/looms.ts" ><b>getLoomUtilByType</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#getNextPath" title="src/app/core/model/yarnsimulation.ts" ><b>getNextPath</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#hasCell" title="src/app/core/model/drafts.ts" ><b>hasCell</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#hasEast" title="src/app/core/model/yarnsimulation.ts" ><b>hasEast</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#hasEastNeighbor" title="src/app/core/model/yarnsimulation.ts" ><b>hasEastNeighbor</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#hasNorth" title="src/app/core/model/yarnsimulation.ts" ><b>hasNorth</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#hasNorthNeighbor" title="src/app/core/model/yarnsimulation.ts" ><b>hasNorthNeighbor</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#hasSouth" title="src/app/core/model/yarnsimulation.ts" ><b>hasSouth</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#hasSouthNeighbor" title="src/app/core/model/yarnsimulation.ts" ><b>hasSouthNeighbor</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#hasWest" title="src/app/core/model/yarnsimulation.ts" ><b>hasWest</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#hasWestNeighbor" title="src/app/core/model/yarnsimulation.ts" ><b>hasWestNeighbor</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#initDraft" title="src/app/core/model/drafts.ts" ><b>initDraft</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#initDraftWithParams" title="src/app/core/model/drafts.ts" ><b>initDraftWithParams</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#insertDrawdownCol" title="src/app/core/model/drafts.ts" ><b>insertDrawdownCol</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#insertDrawdownRow" title="src/app/core/model/drafts.ts" ><b>insertDrawdownRow</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#insertMappingCol" title="src/app/core/model/drafts.ts" ><b>insertMappingCol</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#insertMappingRow" title="src/app/core/model/drafts.ts" ><b>insertMappingRow</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#interlace" title="src/app/mixer/model/op_definitions.ts" ><b>interlace</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#invert" title="src/app/mixer/model/op_definitions.ts" ><b>invert</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#invertDrawdown" title="src/app/core/model/drafts.ts" ><b>invertDrawdown</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#isEast" title="src/app/core/model/yarnsimulation.ts" ><b>isEast</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#isEastWest" title="src/app/core/model/yarnsimulation.ts" ><b>isEastWest</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#isFrame" title="src/app/core/model/looms.ts" ><b>isFrame</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#isInThreadingRange" title="src/app/core/model/looms.ts" ><b>isInThreadingRange</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#isInTieupRange" title="src/app/core/model/looms.ts" ><b>isInTieupRange</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#isInTreadlingRange" title="src/app/core/model/looms.ts" ><b>isInTreadlingRange</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#isInUserThreadingRange" title="src/app/core/model/looms.ts" ><b>isInUserThreadingRange</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#isInUserTieupRange" title="src/app/core/model/looms.ts" ><b>isInUserTieupRange</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#isInUserTreadlingRange" title="src/app/core/model/looms.ts" ><b>isInUserTreadlingRange</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#isNorthEast" title="src/app/core/model/yarnsimulation.ts" ><b>isNorthEast</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#isNorthSouth" title="src/app/core/model/yarnsimulation.ts" ><b>isNorthSouth</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#isNorthWest" title="src/app/core/model/yarnsimulation.ts" ><b>isNorthWest</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#isSet" title="src/app/core/model/drafts.ts" ><b>isSet</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#isSouthEast" title="src/app/core/model/yarnsimulation.ts" ><b>isSouthEast</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#isSouthWest" title="src/app/core/model/yarnsimulation.ts" ><b>isSouthWest</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#isUp" title="src/app/core/model/drafts.ts" ><b>isUp</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#isWest" title="src/app/core/model/yarnsimulation.ts" ><b>isWest</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#jacquard_utils" title="src/app/core/model/looms.ts" ><b>jacquard_utils</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#joinleft" title="src/app/mixer/model/op_definitions.ts" ><b>joinleft</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#jointop" title="src/app/mixer/model/op_definitions.ts" ><b>jointop</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#knockout" title="src/app/mixer/model/op_definitions.ts" ><b>knockout</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#layer" title="src/app/mixer/model/op_definitions.ts" ><b>layer</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#loadDraftFromFile" title="src/app/core/model/drafts.ts" ><b>loadDraftFromFile</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#loadLoomFromFile" title="src/app/core/model/looms.ts" ><b>loadLoomFromFile</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#makesymmetric" title="src/app/mixer/model/op_definitions.ts" ><b>makesymmetric</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#margin" title="src/app/mixer/model/op_definitions.ts" ><b>margin</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#mask" title="src/app/mixer/model/op_definitions.ts" ><b>mask</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#number_to_draft" title="src/app/mixer/model/op_definitions.ts" ><b>number_to_draft</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#numFrames" title="src/app/core/model/looms.ts" ><b>numFrames</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#numTreadles" title="src/app/core/model/looms.ts" ><b>numTreadles</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#OpFactories" title="src/app/mixer/model/operation/topology.ts" ><b>OpFactories</b>&nbsp;&nbsp;&nbsp;(src/.../topology.ts)</a>
                        </li>
                        <li>
                            <a href="#overlay" title="src/app/mixer/model/op_definitions.ts" ><b>overlay</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#parseSavedPattern" title="src/app/core/model/drafts.ts" ><b>parseSavedPattern</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#pasteDirectAndFrameThreading" title="src/app/core/model/looms.ts" ><b>pasteDirectAndFrameThreading</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#pasteDirectAndFrameTreadling" title="src/app/core/model/looms.ts" ><b>pasteDirectAndFrameTreadling</b>&nbsp;&nbsp;&nbsp;(src/.../looms.ts)</a>
                        </li>
                        <li>
                            <a href="#pasteIntoDrawdown" title="src/app/core/model/drafts.ts" ><b>pasteIntoDrawdown</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#pingNeighbors" title="src/app/core/model/yarnsimulation.ts" ><b>pingNeighbors</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#random" title="src/app/mixer/model/op_definitions.ts" ><b>random</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#rect" title="src/app/mixer/model/op_definitions.ts" ><b>rect</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#refresh" title="src/app/player/model/playerop.ts" ><b>refresh</b>&nbsp;&nbsp;&nbsp;(src/.../playerop.ts)</a>
                        </li>
                        <li>
                            <a href="#replicate" title="src/app/mixer/model/op_definitions.ts" ><b>replicate</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#resize" title="src/app/mixer/model/op_definitions.ts" ><b>resize</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#reverse" title="src/app/player/model/playerop.ts" ><b>reverse</b>&nbsp;&nbsp;&nbsp;(src/.../playerop.ts)</a>
                        </li>
                        <li>
                            <a href="#rib" title="src/app/mixer/model/op_definitions.ts" ><b>rib</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#rotate" title="src/app/mixer/model/op_definitions.ts" ><b>rotate</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#satin" title="src/app/mixer/model/op_definitions.ts" ><b>satin</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#selvedge" title="src/app/mixer/model/op_definitions.ts" ><b>selvedge</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#set" title="src/app/mixer/model/op_definitions.ts" ><b>set</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#setEast" title="src/app/core/model/yarnsimulation.ts" ><b>setEast</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#setEastNeighbors" title="src/app/core/model/yarnsimulation.ts" ><b>setEastNeighbors</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#setEastWest" title="src/app/core/model/yarnsimulation.ts" ><b>setEastWest</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#setHeddle" title="src/app/core/model/drafts.ts" ><b>setHeddle</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#setNorth" title="src/app/core/model/yarnsimulation.ts" ><b>setNorth</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#setNorthNeighbors" title="src/app/core/model/yarnsimulation.ts" ><b>setNorthNeighbors</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#setNorthSouth" title="src/app/core/model/yarnsimulation.ts" ><b>setNorthSouth</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#setPoles" title="src/app/core/model/yarnsimulation.ts" ><b>setPoles</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#setSouth" title="src/app/core/model/yarnsimulation.ts" ><b>setSouth</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#setWest" title="src/app/core/model/yarnsimulation.ts" ><b>setWest</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#setWestNeighbors" title="src/app/core/model/yarnsimulation.ts" ><b>setWestNeighbors</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#shaded_satin" title="src/app/mixer/model/op_definitions.ts" ><b>shaded_satin</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#shiftDrawdown" title="src/app/core/model/drafts.ts" ><b>shiftDrawdown</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#shiftx" title="src/app/mixer/model/op_definitions.ts" ><b>shiftx</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#shifty" title="src/app/mixer/model/op_definitions.ts" ><b>shifty</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#slope" title="src/app/mixer/model/op_definitions.ts" ><b>slope</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#stretch" title="src/app/mixer/model/op_definitions.ts" ><b>stretch</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#tabby" title="src/app/mixer/model/op_definitions.ts" ><b>tabby</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#tabby_der" title="src/app/mixer/model/op_definitions.ts" ><b>tabby_der</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#tile" title="src/app/mixer/model/op_definitions.ts" ><b>tile</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#TopologyName" title="src/app/mixer/model/operation/topology.ts" ><b>TopologyName</b>&nbsp;&nbsp;&nbsp;(src/.../topology.ts)</a>
                        </li>
                        <li>
                            <a href="#trim" title="src/app/mixer/model/op_definitions.ts" ><b>trim</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#twill" title="src/app/mixer/model/op_definitions.ts" ><b>twill</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#unset" title="src/app/mixer/model/op_definitions.ts" ><b>unset</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#unsetEast" title="src/app/core/model/yarnsimulation.ts" ><b>unsetEast</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#unsetEastNeighbors" title="src/app/core/model/yarnsimulation.ts" ><b>unsetEastNeighbors</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#unsetNorth" title="src/app/core/model/yarnsimulation.ts" ><b>unsetNorth</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#unsetPole" title="src/app/core/model/yarnsimulation.ts" ><b>unsetPole</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#unsetSouth" title="src/app/core/model/yarnsimulation.ts" ><b>unsetSouth</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#unsetWest" title="src/app/core/model/yarnsimulation.ts" ><b>unsetWest</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#unsetWestNeighbors" title="src/app/core/model/yarnsimulation.ts" ><b>unsetWestNeighbors</b>&nbsp;&nbsp;&nbsp;(src/.../yarnsimulation.ts)</a>
                        </li>
                        <li>
                            <a href="#utilInstance" title="src/app/core/model/util.ts" ><b>utilInstance</b>&nbsp;&nbsp;&nbsp;(src/.../util.ts)</a>
                        </li>
                        <li>
                            <a href="#warps" title="src/app/core/model/drafts.ts" ><b>warps</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                        <li>
                            <a href="#" title="src/app/mixer/model/op_definitions.ts" ><b></b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#variants" title="src/app/mixer/model/op_definitions.ts" ><b>variants</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#waffle" title="src/app/mixer/model/op_definitions.ts" ><b>waffle</b>&nbsp;&nbsp;&nbsp;(src/.../op_definitions.ts)</a>
                        </li>
                        <li>
                            <a href="#wefts" title="src/app/core/model/drafts.ts" ><b>wefts</b>&nbsp;&nbsp;&nbsp;(src/.../drafts.ts)</a>
                        </li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>
</section>

    <h3>src/app/core/model/drafts.ts</h3>
    <section>
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="appendBlankCol"></a>
                    <span class="name">
                        <span ><b>appendBlankCol</b></span>
                        <a href="#appendBlankCol"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown) : Drawdown &#x3D;&gt; {
    for (var i &#x3D; 0; i &lt; wefts(d); i++) {
      d[i].push(new Cell(null));
    }
    return d;
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="applyMask"></a>
                    <span class="name">
                        <span ><b>applyMask</b></span>
                        <a href="#applyMask"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(mask: Drawdown, pattern: Drawdown) : Drawdown &#x3D;&gt;  {
    
    const res &#x3D; createBlankDrawdown(wefts(mask), warps(mask));
    for(let i &#x3D; 0; i &lt; wefts(mask); i++){
      for(let j &#x3D; 0; j &lt; warps(mask); j++){
        if(mask[i][j].getHeddle()){
          const set_to &#x3D; pattern[i%wefts(pattern)][j%warps(pattern)].getHeddle();
          res[i][j].setHeddle(set_to);
        }
        
      }
    } 
    return res;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>applys a pattern only to regions where the input draft has true heddles</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="createBlankDrawdown"></a>
                    <span class="name">
                        <span ><b>createBlankDrawdown</b></span>
                        <a href="#createBlankDrawdown"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(wefts: number, warps: number) : Drawdown &#x3D;&gt; {
    const drawdown: Drawdown &#x3D; [];
    for(let i &#x3D; 0; i &lt; wefts; i++){
      drawdown.push([]);
      for(let j &#x3D; 0; j &lt; warps; j++){
        drawdown[i].push(new Cell(false));
      }
    } 
    return drawdown;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>creates an empty drawdown of a given size</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="createDraft"></a>
                    <span class="name">
                        <span ><b>createDraft</b></span>
                        <a href="#createDraft"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(
  pattern: Drawdown,
  gen_name: string,
  ud_name: string,
  rowShuttleMapping: Array&lt;any&gt;,
  rowSystemMapping: Array&lt;any&gt;,
  colShuttleMapping: Array&lt;any&gt;,
  colSystemMapping: Array&lt;any&gt;
  ) : Draft &#x3D;&gt; {

    const d: Draft &#x3D; {
      id: utilInstance.generateId(8),
      drawdown: pattern.slice(),
      gen_name: gen_name,
      ud_name: ud_name, 
      rowShuttleMapping: rowShuttleMapping.slice(),
      rowSystemMapping: rowSystemMapping.slice(),
      colShuttleMapping: colShuttleMapping.slice(),
      colSystemMapping: colSystemMapping.slice(),
    }

    return d;

  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>generates a new draft from the paramters specified.</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="deleteDrawdownCol"></a>
                    <span class="name">
                        <span ><b>deleteDrawdownCol</b></span>
                        <a href="#deleteDrawdownCol"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown, j: number) : Drawdown &#x3D;&gt; {

    for(var ndx &#x3D; 0; ndx &lt; wefts(d); ndx++){
      d[ndx].splice(j, 1);
    }
    return d;

  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>delete a column from the drawdown at a given location</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="deleteDrawdownRow"></a>
                    <span class="name">
                        <span ><b>deleteDrawdownRow</b></span>
                        <a href="#deleteDrawdownRow"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d:Drawdown, i: number) : Drawdown &#x3D;&gt; {
      try{
        d.splice(i, 1);
      }catch(e){
        console.error(e);
      }
      return d;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>deletes a row from the drawdown at the specified weft location</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="deleteMappingCol"></a>
                    <span class="name">
                        <span ><b>deleteMappingCol</b></span>
                        <a href="#deleteMappingCol"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(m: Array&lt;number&gt;, j: number) : Array&lt;number&gt; &#x3D;&gt; {
    m.splice(j, 1);
    return m;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>deletes a value into the col system/shuttle mapping at a particular location</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="deleteMappingRow"></a>
                    <span class="name">
                        <span ><b>deleteMappingRow</b></span>
                        <a href="#deleteMappingRow"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(m:Array&lt;number&gt;, i: number) : Array&lt;number&gt; &#x3D;&gt; {
    try{
      m.splice(i, 1);
    }catch(e){
      console.error(e);
    }
    return m;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>deletes a row from a row system/shuttle mapping at the specified weft location</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="flipDraft"></a>
                    <span class="name">
                        <span ><b>flipDraft</b></span>
                        <a href="#flipDraft"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Draft, horiz: boolean, vert: boolean) : Promise&lt;Draft&gt; &#x3D;&gt; {
  console.log(&quot;flip draft call input: &quot;, d);
  const draft &#x3D; initDraftWithParams(
    {id: d.id, 
    gen_name: d.gen_name,
    wefts: wefts(d.drawdown),
    warps: warps(d.drawdown),
    ud_name: d.ud_name,
    colShuttleMapping: d.colShuttleMapping,
    colSystemMapping: d.colSystemMapping});
    draft.drawdown &#x3D; createBlankDrawdown(wefts(d.drawdown), warps(d.drawdown));

  console.log(&quot;starting &quot;, draft);

  for(let i &#x3D; 0; i &lt; wefts(d.drawdown); i++){
    let flipped_i &#x3D; i;
    if(vert) flipped_i &#x3D; wefts(d.drawdown) -1 -i;
    for(let j &#x3D; 0; j &lt; warps(d.drawdown); j++){
      let flipped_j &#x3D; j;
      if(horiz) flipped_j &#x3D; warps(d.drawdown) -1 -j;
      draft.drawdown[i][j].setHeddle(d.drawdown[flipped_i][flipped_j].getHeddle()); 
    }

    draft.rowShuttleMapping[i] &#x3D; d.rowShuttleMapping[flipped_i];
    draft.rowSystemMapping[i] &#x3D; d.rowSystemMapping[flipped_i];
   }

   if(horiz){
    
    for(let j &#x3D; 0; j &lt; warps(d.drawdown); j++){
      let flipped_j &#x3D; warps(d.drawdown) -1 -j;
      draft.colShuttleMapping[j] &#x3D; d.colShuttleMapping[flipped_j];
      draft.colSystemMapping[j] &#x3D; d.colSystemMapping[flipped_j];
    }
  }


  console.log(&quot;flipped draft id: &quot;, draft.id);
  return Promise.resolve(draft);
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>takes a draft as input, and flips the order of the rows
used to ensure mixer calculations are oriented from bottom left</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="flipDrawdown"></a>
                    <span class="name">
                        <span ><b>flipDrawdown</b></span>
                        <a href="#flipDrawdown"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(drawdown: Drawdown, horiz: boolean) : Drawdown &#x3D;&gt;  {

    const flip &#x3D; createBlankDrawdown(wefts(drawdown), warps(drawdown));
    for(let i &#x3D; 0; i &lt; wefts(drawdown); i++){
      for(let j &#x3D; 0; j &lt; warps(drawdown); j++){
          let set_to &#x3D; false;
          if(horiz)  set_to &#x3D; drawdown[i][warps(drawdown)-1-j].getHeddle();
          else set_to &#x3D; drawdown[wefts(drawdown)-1 - i][j].getHeddle();
          flip[i][j].setHeddle(set_to);
      }
    } 
    return flip;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>flips the drawdown horizontally or vertically. This is different than flip draft because it only 
flippes teh drawdown, not any other associated information</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="generateMappingFromPattern"></a>
                    <span class="name">
                        <span ><b>generateMappingFromPattern</b></span>
                        <a href="#generateMappingFromPattern"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(drawdown: Drawdown, pattern: Array&lt;number&gt;, type: string, origin: number) : Array&lt;any&gt; &#x3D;&gt; {

    const mapping: Array&lt;number&gt; &#x3D; [];
    if(type &#x3D;&#x3D; &#x27;row&#x27;){

        if(origin &#x3D;&#x3D; 1 || origin &#x3D;&#x3D; 2) pattern &#x3D; pattern.slice().reverse();

        for(let i &#x3D; 0; i &lt; wefts(drawdown); i++){
          mapping.push(pattern[i%pattern.length]);
        }

    }else{

        if(origin &#x3D;&#x3D; 0 || origin &#x3D;&#x3D; 1) pattern &#x3D; pattern.slice().reverse();

        for(let j &#x3D; 0; j &lt; warps(drawdown); j++){
          mapping.push(pattern[j%pattern.length]);
        }
      
    }

    return mapping.slice();
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>generates a system or shuttle mapping from an input pattern based on the input draft</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="getDraftName"></a>
                    <span class="name">
                        <span ><b>getDraftName</b></span>
                        <a href="#getDraftName"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(draft: Draft) : string &#x3D;&gt; {
  if(draft &#x3D;&#x3D;&#x3D; null || draft &#x3D;&#x3D;&#x3D; undefined) return &quot;&quot;; 
  if(draft.ud_name &#x3D;&#x3D; undefined){
    if(draft.gen_name &#x3D;&#x3D; undefined) return &#x27;&#x27;;
    else return draft.gen_name;
  }  

  if(draft.gen_name &#x3D;&#x3D; undefined){
    if(draft.ud_name &#x3D;&#x3D; undefined) return &#x27;&#x27;;
    else return draft.ud_name;
  }

  return (draft.ud_name &#x3D;&#x3D;&#x3D; &quot;&quot;) ?  draft.gen_name : draft.ud_name; 
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>gets the name of the draft. If it has a user defined name, it returns that, otherwise, it returns the generated name</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="getHeddle"></a>
                    <span class="name">
                        <span ><b>getHeddle</b></span>
                        <a href="#getHeddle"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown, i: number, j: number) : boolean &#x3D;&gt; {
    if(i &gt; wefts(d) || j &gt; warps(d)) return null;
    return d[i][j].getHeddle();
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>get the value of the heddle at a given location</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="hasCell"></a>
                    <span class="name">
                        <span ><b>hasCell</b></span>
                        <a href="#hasCell"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown, i:number, j:number) : boolean &#x3D;&gt;{
    if(i &lt; 0 || i &gt;&#x3D; wefts(d)) return false;
    if(j &lt; 0 || j &gt;&#x3D; warps(d)) return false;
    return true;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>check if the giver interlacement within the size of the draft</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="initDraft"></a>
                    <span class="name">
                        <span ><b>initDraft</b></span>
                        <a href="#initDraft"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>() : Draft &#x3D;&gt; {
  const d: Draft &#x3D; {
    id: utilInstance.generateId(8),
    gen_name: &#x27;draft&#x27;,
    ud_name: &quot;&quot;,
    drawdown: [],
    rowShuttleMapping: [],
    rowSystemMapping: [],
    colShuttleMapping: [],
    colSystemMapping: []

  };
  console.log(&quot;initiated draft id: &quot;, d.id);
  return d;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>generates an empty draft with a unique id</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="initDraftWithParams"></a>
                    <span class="name">
                        <span ><b>initDraftWithParams</b></span>
                        <a href="#initDraftWithParams"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(params: any) : Draft &#x3D;&gt; {
  const d: Draft &#x3D; {
    id: utilInstance.generateId(8),
    gen_name: &#x27;draft&#x27;,
    ud_name: &quot;&quot;,
    drawdown: [],
    rowShuttleMapping: [],
    rowSystemMapping: [],
    colShuttleMapping: [],
    colSystemMapping: []

  };

  console.log(&quot;generated draft id: &quot;, d.id);


  if(params.id !&#x3D;&#x3D; undefined ) d.id &#x3D; params.id;
  if(params.gen_name !&#x3D;&#x3D; undefined ) d.gen_name &#x3D; params.gen_name;
  if(params.ud_name !&#x3D;&#x3D; undefined ) d.ud_name &#x3D; params.ud_name;
 
  //handle common error
  if(params.pattern !&#x3D;&#x3D; undefined) params.drawdown &#x3D; params.pattern;
  //start with empty draft 

  if(params.wefts &#x3D;&#x3D;&#x3D; undefined ){
    if(params.drawdown &#x3D;&#x3D; undefined) params.wefts &#x3D; 1;
    else params.wefts &#x3D; wefts(params.drawdown);
  }

  if(params.warps &#x3D;&#x3D;&#x3D; undefined){
    if(params.drawdown &#x3D;&#x3D; undefined)  params.warps &#x3D; 1;
    else params.warps &#x3D; warps(params.drawdown);
  } 
 
  for(let i &#x3D; 0; i &lt; params.wefts; i++){
    d.drawdown.push([]);
    d.rowSystemMapping.push(0);
    d.rowShuttleMapping.push(1);
    for(let j &#x3D; 0; j &lt; params.warps; j++){
      d.drawdown[i][j] &#x3D; new Cell(false);
    }
  }

  for(let j &#x3D; 0; j &lt; params.warps; j++){
    d.colSystemMapping.push(0);
    d.colShuttleMapping.push(0);
  }

  if(params.drawdown !&#x3D;&#x3D; undefined){
    d.drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {
       cell.setHeddle(params.drawdown[i%wefts(params.drawdown)][j%warps(params.drawdown)].getHeddle());
      })
    })
  }

  if(params.rowShuttleMapping !&#x3D;&#x3D; undefined){
    for(let i &#x3D; 0; i &lt; wefts(d.drawdown); i++){
      d.rowShuttleMapping[i] &#x3D; params.rowShuttleMapping[i%params.rowShuttleMapping.length];
    }
  }

  if(params.rowSystemMapping !&#x3D;&#x3D; undefined){
    for(let i &#x3D; 0; i &lt; wefts(d.drawdown); i++){
      d.rowSystemMapping[i] &#x3D; params.rowSystemMapping[i%params.rowSystemMapping.length];
    }
  }

  if(params.colShuttleMapping !&#x3D;&#x3D; undefined){
    for(let i &#x3D; 0; i &lt; warps(d.drawdown); i++){
      d.colShuttleMapping[i] &#x3D; params.colShuttleMapping[i%params.colShuttleMapping.length];
    }
  }

  if(params.colSystemMapping !&#x3D;&#x3D; undefined){
    for(let i &#x3D; 0; i &lt; warps(d.drawdown); i++){
      d.colSystemMapping[i] &#x3D; params.colSystemMapping[i%params.colSystemMapping.length];
    }
  }

  console.log(&quot;finished draft id: &quot;, d.id);

  return d;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>creates a draft based on the params provided.</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="insertDrawdownCol"></a>
                    <span class="name">
                        <span ><b>insertDrawdownCol</b></span>
                        <a href="#insertDrawdownCol"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown, j: number, col: Array&lt;Cell&gt;) : Drawdown &#x3D;&gt; {
    
    const w &#x3D; warps(d);

    if(j &#x3D;&#x3D;&#x3D; null) j &#x3D;0;

    if(col &#x3D;&#x3D; null){
      col &#x3D; [];
      for(let i &#x3D; 0; i &lt; wefts(d); i++){
        col.push(new Cell(false));
      }
    }
    for (var ndx &#x3D; 0; ndx &lt; wefts(d); ndx++) {
      d[ndx].splice(j, 0, new Cell(col[ndx].getHeddle()));
    }
    return d;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>inserts a column into the drawdown</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="insertDrawdownRow"></a>
                    <span class="name">
                        <span ><b>insertDrawdownRow</b></span>
                        <a href="#insertDrawdownRow"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown, i: number, row: Array&lt;Cell&gt;) : Drawdown &#x3D;&gt; {
    i &#x3D; i+1;

    if(row &#x3D;&#x3D;&#x3D; null){
      row &#x3D; [];
      for (var j &#x3D; 0; j &lt; warps(d); j++) {
        row.push(new Cell(false));
      }
    }
    if(row.length !&#x3D;&#x3D; warps(d)) console.error(&quot;inserting row of incorrect length into drawdown&quot;);
   
    try{
      d.splice(i,0,row);
    }catch(e){
      console.error(e);
    }
    return d;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>I DON&quot;T THINK THIS FUNCTION WORKS OR IS BEING USED
removes any boundary rows from the input draft that are unset</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="insertMappingCol"></a>
                    <span class="name">
                        <span ><b>insertMappingCol</b></span>
                        <a href="#insertMappingCol"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(m: Array&lt;number&gt;, j: number, col: number) : Array&lt;number&gt; &#x3D;&gt; {
    m.splice(j,0, col);
    return m;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>inserts a value into the col system/shuttle mapping at a particular location</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="insertMappingRow"></a>
                    <span class="name">
                        <span ><b>insertMappingRow</b></span>
                        <a href="#insertMappingRow"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(m: Array&lt;number&gt;, i: number, val: number) : Array&lt;number&gt; &#x3D;&gt; {
    i &#x3D; i+1;
    try{
      m.splice(i,0,val);
    }catch(e){
      console.error(e);
    }
    return m;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>inserts a new value into the row system/shuttle map</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="invertDrawdown"></a>
                    <span class="name">
                        <span ><b>invertDrawdown</b></span>
                        <a href="#invertDrawdown"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(drawdown: Drawdown) : Drawdown &#x3D;&gt;  {
    
    const inverted &#x3D; drawdown.slice();
    for(let i &#x3D; 0; i &lt; wefts(drawdown); i++){
      for(let j &#x3D; 0; j &lt; warps(drawdown); j++){
        if(drawdown[i][j].isSet()){
          const set_to &#x3D; !drawdown[i][j].getHeddle();
          inverted[i][j].setHeddle(set_to);
        }
        
      }
    } 
    return inverted;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>inverts the drawdown (e.g. sets true cells to false and vice versa)</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isSet"></a>
                    <span class="name">
                        <span ><b>isSet</b></span>
                        <a href="#isSet"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown, i:number, j:number) : boolean &#x3D;&gt; {
    if ( i &gt; -1 &amp;&amp; i &lt; wefts(d) &amp;&amp; j &gt; -1 &amp;&amp; j &lt; warps(d)) {
      return d[i][j].isSet();
    } else {
      return false;
    }
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>checks if the cells in the provided drawdown is set or unset</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isUp"></a>
                    <span class="name">
                        <span ><b>isUp</b></span>
                        <a href="#isUp"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown, i:number, j:number) : boolean &#x3D;&gt;{
    //console.log(&quot;is up&quot;, i, j, wefts(d), warps(d), d[i][j]);
    if ( i &gt; -1 &amp;&amp; i &lt; wefts(d) &amp;&amp; j &gt; -1 &amp;&amp; j &lt; warps(d)) {
      return d[i][j].isUp();
    } else {
      return false;
    }
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>checks if the cells in the provided drawdown is up</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="loadDraftFromFile"></a>
                    <span class="name">
                        <span ><b>loadDraftFromFile</b></span>
                        <a href="#loadDraftFromFile"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(data: any, flips: any, version: string) : Promise&lt;Draft&gt; &#x3D;&gt; {

    const draft: Draft &#x3D; initDraft();
    if(data.id !&#x3D;&#x3D; undefined) draft.id &#x3D; data.id;
    draft.gen_name &#x3D; (data.gen_name &#x3D;&#x3D;&#x3D; undefined) ? &#x27;draft&#x27; : data.gen_name;
    draft.ud_name &#x3D; (data.ud_name &#x3D;&#x3D;&#x3D; undefined) ? &#x27;&#x27; : data.ud_name;
    
    if(version &#x3D;&#x3D;&#x3D; undefined || version &#x3D;&#x3D;&#x3D; null || !utilInstance.sameOrNewerVersion(version, &#x27;3.4.5&#x27;)){
      draft.drawdown &#x3D; parseSavedPattern(data.pattern);
    }else{
      draft.drawdown &#x3D; parseSavedPattern(data.drawdown);
    }

    draft.rowShuttleMapping &#x3D; (data.rowShuttleMapping &#x3D;&#x3D;&#x3D; undefined) ? [] : data.rowShuttleMapping;
    draft.rowSystemMapping &#x3D; (data.rowSystemMapping &#x3D;&#x3D;&#x3D; undefined) ? [] : data.rowSystemMapping;
    draft.colShuttleMapping &#x3D; (data.colShuttleMapping &#x3D;&#x3D;&#x3D; undefined) ? [] : data.colShuttleMapping;;
    draft.colSystemMapping&#x3D; (data.colSystemMapping &#x3D;&#x3D;&#x3D; undefined) ? [] : data.colSystemMapping;;


    return flipDraft(draft, flips.horiz, flips.vert)
    .then(flipped &#x3D;&gt; {
      return flipped;
    })
    
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>sets up the draft from the information saved in a .ada file</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="parseSavedPattern"></a>
                    <span class="name">
                        <span ><b>parseSavedPattern</b></span>
                        <a href="#parseSavedPattern"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(pattern: Array&lt;Array&lt;boolean&gt;&gt;) : Drawdown &#x3D;&gt; {
    const drawdown:Drawdown &#x3D; [];
    if(pattern &#x3D;&#x3D;&#x3D; undefined) return [];

    for(var i &#x3D; 0; i &lt; wefts(pattern); i++) {
        drawdown.push([]);
        for (var j &#x3D; 0; j &lt; warps(pattern); j++){
          drawdown[i][j]&#x3D; new Cell(null);
          drawdown[i][j].reloadCell(pattern[i][j]); //this takes a cell param and updates from there
        }
    }
    return drawdown;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>converts the saved structure of a pattern into the format used in memory</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="pasteIntoDrawdown"></a>
                    <span class="name">
                        <span ><b>pasteIntoDrawdown</b></span>
                        <a href="#pasteIntoDrawdown"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(
    drawdown: Drawdown, 
    fill_pattern: Drawdown,
    start_i: number,
    start_j: number,
    width: number,
    height: number 

  ) :  Drawdown &#x3D;&gt;  {


    let rows &#x3D; wefts(fill_pattern);
    let cols &#x3D; warps(fill_pattern);

    //cycle through each visible row/column of the selection
    for (var i &#x3D; 0; i &lt; height; i++ ) {
      for (var j &#x3D; 0; j &lt; width; j++ ) {
        try{
          drawdown[start_i+i][start_j+j].setHeddle(fill_pattern[i % rows][j % cols].getHeddle());
        }catch(e){
          console.error(e);
        }
      }
    }

    return drawdown;

   
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>pasts a second drawdown representing a pattern at the specified location and size</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setHeddle"></a>
                    <span class="name">
                        <span ><b>setHeddle</b></span>
                        <a href="#setHeddle"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d:Drawdown, i:number, j:number, bool:boolean) : Drawdown &#x3D;&gt; {
      d[i][j].setHeddle(bool);
      return d;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>sets the heddle at the specified location to the value provided</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="shiftDrawdown"></a>
                    <span class="name">
                        <span ><b>shiftDrawdown</b></span>
                        <a href="#shiftDrawdown"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(drawdown: Drawdown, up: boolean, inc: number) : Drawdown &#x3D;&gt;  {

      const shifted &#x3D; createBlankDrawdown(wefts(drawdown), warps(drawdown));
      for(let i &#x3D; 0; i &lt; wefts(drawdown); i++){
        for(let j &#x3D; 0; j &lt; warps(drawdown); j++){
            let set_to &#x3D; false;
            if(up)  set_to &#x3D; drawdown[(i+inc)%wefts(drawdown)][j].getHeddle();
            else set_to &#x3D; drawdown[i][(j+inc)%warps(drawdown)].getHeddle();
            shifted[i][j].setHeddle(set_to);
        }
      } 
      return shifted;
    }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>shifts the drawdown up or left by the amount specified.</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="warps"></a>
                    <span class="name">
                        <span ><b>warps</b></span>
                        <a href="#warps"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown | Array&lt;Array&lt;any&gt;&gt;) :  number &#x3D;&gt; {
    if(d &#x3D;&#x3D;&#x3D; null || d &#x3D;&#x3D; undefined) return 0;
    if(d[0] &#x3D;&#x3D;&#x3D; undefined) return 0;
    return d[0].length;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>calcualte the number of warps (cols) in a pattern</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="wefts"></a>
                    <span class="name">
                        <span ><b>wefts</b></span>
                        <a href="#wefts"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown | Array&lt;Array&lt;any&gt;&gt;) :  number &#x3D;&gt; {
    if(d &#x3D;&#x3D;&#x3D; null || d &#x3D;&#x3D; undefined) return 0;
    return d.length;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>calcualte the number of wefts (rows) in a pattern</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
</section>
    <h3>src/app/mixer/model/op_definitions.ts</h3>
    <section>
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="apply_mats"></a>
                    <span class="name">
                        <span ><b>apply_mats</b></span>
                        <a href="#apply_mats"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.NoParams({
  name: &#x27;apply materials&#x27;,
  displayname: &#x27;apply materials&#x27;,  
  old_names:[],    
  dx: &quot;applies the materials from the second draft onto the first draft. If they are uneven sizes, it will repeat the materials as a pattern&quot;,
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to which you would like to apply materials&#x27;,
    num_drafts: 1 },
    {
    name: &#x27;materials&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;a draft which has the materials youd like to apply&#x27;,
    num_drafts: 1
    }
  ],
  perform: (inputs: Array&lt;Draft&gt;) &#x3D;&gt; {
    // const parent_input &#x3D; op_inputs.find(el &#x3D;&gt; el.op_name &#x3D;&#x3D; &#x27;apply materials&#x27;);
    // const child_input &#x3D; op_inputs.find(el &#x3D;&gt; el.op_name &#x3D;&#x3D; &#x27;child&#x27;);
    // const materials &#x3D; inputs[1];
    // const inputdraft &#x3D; inputs[0];

    // if (child_input &#x3D;&#x3D;&#x3D; undefined) return Promise.resolve([]);
    // if (materials &#x3D;&#x3D;&#x3D; undefined) return Promise.resolve([inputs[0]])
    // if (inputdraft &#x3D;&#x3D;&#x3D; undefined) return Promise.resolve([materials.drafts[0]])
    const d: Draft &#x3D; initDraftWithParams({
      warps:warps(inputs[0].drawdown), 
      wefts:wefts(inputs[0].drawdown),
      rowShuttleMapping: inputs[1].rowShuttleMapping,
      rowSystemMapping: inputs[0].rowSystemMapping,
      colShuttleMapping: inputs[1].colShuttleMapping,
      colSystemMapping: inputs[0].colSystemMapping,
    });
    inputs[0].drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {
        d.drawdown[i][j] &#x3D; new Cell(cell.getHeddle());
      });
    });
    d.gen_name &#x3D; formatName(inputs, &#x27;materials&#x27;)
    return d;
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="atop"></a>
                    <span class="name">
                        <span ><b>atop</b></span>
                        <a href="#atop"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
  name: &#x27;set atop, (a, b) &#x3D;&gt; a&#x27;,
  displayname: &#x27;set atop, (a, b) &#x3D;&gt; b&#x27;, 
  old_names:[&#x27;set atop&#x27;], 
  dx: &#x27;sets cells of a on top of b, no matter the value of b&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;left offset&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &quot;the amount to offset the addedop_input.drafts from the left&quot;
    },
    {name: &#x27;bottom offset&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &quot;the amount to offset the overlayingop_input.drafts from the bottom&quot;
    }
  ],
  inlets: [{
    name: &#x27;a&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;all the drafts you would like to set another on top of&#x27;,
    num_drafts: 1
  },
  {
    name: &#x27;b&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft you would like to set atop the base&#x27;,
    num_drafts: 1
  }],
  perform: (inputs: Array&lt;Draft&gt;, params: Array&lt;number&gt;) &#x3D;&gt; {
    const base &#x3D; inputs[0];
    const top &#x3D; inputs[1];

    if(top &#x3D;&#x3D;&#x3D; undefined) return base;

    const first: Draft &#x3D; inputs.shift();

    const outputs: Array&lt;Draft&gt; &#x3D; [];


    let width: number &#x3D; utilInstance.getMaxWarps(inputs) +params[0];
    let height: number &#x3D; utilInstance.getMaxWefts(inputs) +params[1];
    if (warps(first.drawdown) &gt; width) width &#x3D; warps(first.drawdown);
    if (wefts(first.drawdown) &gt; height) height &#x3D; wefts(first.drawdown);

    //initialize the base container with the first draft at 0,0, unset for anythign wider
    const init_draft: Draft &#x3D; initDraftWithParams({wefts: height, warps: width});
      
    first.drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {
        init_draft.drawdown[i][j].setHeddle(cell.getHeddle());
      });
    });

    //now merge in all of the additionalop_input.drafts offset by theop_input.drafts
    const d: Draft &#x3D; inputs.reduce((acc, input) &#x3D;&gt; {
      input.drawdown.forEach((row, i) &#x3D;&gt; {
        row.forEach((cell, j) &#x3D;&gt; {
          //if i or j is less than input params 
          const adj_i: number &#x3D; i+params[1];
          const adj_j: number &#x3D; j+params[0];
          acc.drawdown[adj_i][adj_j].setHeddle(utilInstance.computeFilter(&#x27;up&#x27;, cell.getHeddle(), acc.drawdown[adj_i][adj_j].getHeddle()));
        });
      });
      return acc;

    }, init_draft);
    // format.transferSystemsAndShuttles(d, inputs, params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName(inputs, &quot;atop&quot;)
    return d;
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="basket"></a>
                    <span class="name">
                        <span ><b>basket</b></span>
                        <a href="#basket"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.DraftsOptional({
  name: &#x27;basket&#x27;,
  displayname: &#x27;basket&#x27;,
  old_names: [],
  dx: &#x27;generates a basket structure defined by theop_input.drafts&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;unders&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 2,
    dx: &#x27;number of weft unders&#x27;
    },
    {name: &#x27;overs&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 2,
    dx: &#x27;number of weft overs&#x27;
    }
  ],
  inlets: [{
    name: &#x27;shape&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the shape you would like to fill with this twill&#x27;,
    num_drafts: 1
  }],
  perform: (params: Array&lt;number&gt;, input?: Draft) &#x3D;&gt; {
    const sum: number &#x3D; params.reduce( (acc, val) &#x3D;&gt; {
        return val + acc;
    }, 0);

    let alt_rows, alt_cols, val: boolean &#x3D; false;
    const pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];
    for (let i &#x3D; 0; i &lt; sum; i++) {
      alt_rows &#x3D; (i % sum &lt;params[0]);
      pattern.push([]);
      for(let j &#x3D; 0; j &lt; sum; j++){
        alt_cols &#x3D; (j % sum &lt;params[0]);
        val &#x3D; (alt_cols &amp;&amp; alt_rows) || (!alt_cols &amp;&amp; !alt_rows);
        pattern[i][j] &#x3D;  new Cell(val);
      }
    }

    let d: Draft;
    if (input &#x3D;&#x3D; undefined) {
      d &#x3D; initDraftWithParams({warps: sum, wefts: sum, pattern: pattern});
      d.gen_name &#x3D; formatName([], &quot;basket&quot;);
    } else {
      d &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
      d.drawdown &#x3D; applyMask(input.drawdown, pattern);         
      // format.transferSystemsAndShuttles(d, [input], params, &#x27;first&#x27;);
      d.gen_name &#x3D; formatName([input], &quot;basket&quot;)
    }

    return d;
    }

  })</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="bindwarpfloats"></a>
                    <span class="name">
                        <span ><b>bindwarpfloats</b></span>
                        <a href="#bindwarpfloats"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;bind warp floats&#x27;,
  displayname: &#x27;bind warp floats&#x27;,
  old_names: [],
  dx: &#x27;adds interlacements to warp floats over the user specified length&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt; [
    {name: &#x27;length&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 10,
    dx: &#x27;the maximum length of a warp float&#x27;
    }
  ],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to bind&#x27;,
    num_drafts: 1
  }], 
  perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
    const d: Draft &#x3D; initDraftWithParams({
      warps: warps(input.drawdown), 
      wefts: wefts(input.drawdown), 
      pattern: input.drawdown
    });

    let float: number &#x3D; 0;
    let last: boolean &#x3D; false;

    for (let j &#x3D; 0; j &lt; warps(d.drawdown); j++) {
      const col: Array&lt;Cell&gt; &#x3D; d.drawdown.map(row &#x3D;&gt; row[j]);
      float &#x3D; 0;
      last &#x3D; null;
      col.forEach(c &#x3D;&gt; {
        if (c.getHeddle &#x3D;&#x3D; null) float &#x3D; 0;
        if (last !&#x3D; null &amp;&amp; c.getHeddle() &#x3D;&#x3D; last) float++;

        if (float &gt;&#x3D; params[0]){
          c.toggleHeddle();
          float &#x3D; 0;
        }
        last &#x3D; c.getHeddle();
      });
    }
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="bindweftfloats"></a>
                    <span class="name">
                        <span ><b>bindweftfloats</b></span>
                        <a href="#bindweftfloats"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;bind weft floats&#x27;,
  displayname: &#x27;bind weft floats&#x27;,
  old_names: [],
  dx: &#x27;adds interlacements to weft floats over the user specified length&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;length&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 10,
    dx: &#x27;the maximum length of a weft float&#x27;
  }],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to bind&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
    const d: Draft &#x3D; initDraftWithParams({
      warps: warps(input.drawdown), 
      wefts: wefts(input.drawdown), 
      pattern: input.drawdown
    });
    let float: number &#x3D; 0;
    let last: boolean &#x3D; false;
    d.drawdown.forEach(row &#x3D;&gt; {
      float &#x3D; 0;
      last &#x3D; null;
      row.forEach(c &#x3D;&gt; {
        if(c.getHeddle &#x3D;&#x3D; null) float &#x3D; 0;
        if(last !&#x3D; null &amp;&amp; c.getHeddle() &#x3D;&#x3D; last) float++;

        if (float &gt;&#x3D; params[0]) {
          c.toggleHeddle();
          float &#x3D; 0;
        }
        last &#x3D; c.getHeddle();
      });
    });
  
    // format.transferSystemsAndShuttles(d, [input], params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;bindweft&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="chaos"></a>
                    <span class="name">
                        <span ><b>chaos</b></span>
                        <a href="#chaos"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
    name: &#x27;chaos&#x27;,
    displayname: &#x27;chaos sequence&#x27;,
    dx: &#x27;tiles the input drafts, randomly selecting which draft to place at which position&#x27;,
    old_names: [],
    params: &lt;Array&lt;NumParam&gt;&gt; [
      {name: &#x27;warp-repeats&#x27;,
      type: &#x27;number&#x27;,
      min: 1,
      max: 100,
      value: 2,
      dx: &#x27;the number of times to repeat this time across the width&#x27;
      },
      {name: &#x27;weft-repeats&#x27;,
      type: &#x27;number&#x27;,
      min: 1,
      max: 100,
      value: 2,
      dx: &#x27;the number of times to repeat this time across the length&#x27;
      }
    ],
    inlets: [{
      name: &#x27;draft&#x27;, 
      type: &#x27;static&#x27;,
      value: null,
      dx: &#x27;the draft to tile in the chaos sequence&#x27;,
      num_drafts: -1
    }],
    perform: (inputs: Array&lt;Draft&gt;, params: Array&lt;number&gt;) &#x3D;&gt; {
      const all_drafts &#x3D; inputs;

      const all_warps &#x3D; all_drafts.map(el &#x3D;&gt; warps(el.drawdown)).filter(el &#x3D;&gt; el &gt; 0);
      const total_warps &#x3D; utilInstance.lcm(all_warps);

      const all_wefts &#x3D; all_drafts.map(el &#x3D;&gt; wefts(el.drawdown)).filter(el &#x3D;&gt; el &gt; 0);
      const total_wefts &#x3D; utilInstance.lcm(all_wefts);
      const num_inputs &#x3D; all_drafts.length;

      const warp_repeats &#x3D; params[0];
      const weft_repeats &#x3D; params[1];

      // generate a randomized array of the drafts to tile, flipping chaotically
      const draft_indexing: Array&lt;Array&lt;Draft&gt;&gt; &#x3D; [];
      let ndx &#x3D; Math.floor(Math.random()*num_inputs);
      for (let i &#x3D; 0; i &lt; weft_repeats; i++) {
        draft_indexing.push([]);
        for(let j &#x3D; 0; j &lt; warp_repeats; j++){
          let d &#x3D; all_drafts[ndx];
          const x_flip &#x3D; (Math.random() &lt; 0.5) ? false: true; 
          const y_flip &#x3D; (Math.random() &lt; 0.5) ? false: true; 
          
          if (x_flip) d &#x3D; flipx.perform(d);
          if (y_flip) d &#x3D; flipy.perform(d);

          draft_indexing[i].push(d);
          ndx &#x3D; Math.floor(Math.random()*num_inputs);
        }
      }

      const width: number &#x3D; warp_repeats*total_warps;
      const height: number &#x3D; weft_repeats*total_wefts;
      const output: Draft &#x3D; initDraftWithParams({warps: width, wefts: height});

      output.drawdown.forEach((row, i) &#x3D;&gt; {
        let draft_index_row  &#x3D; Math.floor(i / total_wefts);
        let within_draft_row &#x3D; i % total_wefts;
        row.forEach((cell, j) &#x3D;&gt; {
          let draft_index_col  &#x3D; Math.floor(j / total_warps);
          let within_draft_col  &#x3D; j % total_warps;

          const draft &#x3D; draft_indexing[draft_index_row][draft_index_col];

          const w &#x3D; warps(draft.drawdown);
          const h &#x3D; wefts(draft.drawdown);
          cell.setHeddle(draft.drawdown[within_draft_row%w][within_draft_col%h].getHeddle()); 

        });
      });
      

      // format.transferSystemsAndShuttles(output, all_drafts, params, &#x27;first&#x27;);
      output.gen_name &#x3D; formatName(all_drafts, &quot;chaos&quot;);
    
      return output;  
    }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="clear"></a>
                    <span class="name">
                        <span ><b>clear</b></span>
                        <a href="#clear"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.NoParams({
    name: &#x27;clear&#x27;,
    displayname: &#x27;clear&#x27;,
    old_names: [],
    dx: &quot;this sets all heddles to lifted, allowing it to be masked by any pattern&quot;,
    inlets: [{
      name: &#x27;input draft&#x27;, 
      type: &#x27;static&#x27;,
      value: null,
      dx: &#x27;the draft you would like to clear&#x27;,
      num_drafts: 1
    }],
    perform: (input: Draft): Draft &#x3D;&gt; {
      const d: Draft &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), drawdown: [[new Cell(false)]]});
      // format.transferSystemsAndShuttles(d, [input], {}, &#x27;first&#x27;);
      d.gen_name &#x3D; formatName([input], &quot;clear&quot;);
      return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="complextwill"></a>
                    <span class="name">
                        <span ><b>complextwill</b></span>
                        <a href="#complextwill"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.DraftsOptional({
  name: &#x27;complextwill&#x27;,
  displayname: &#x27;complex twill&#x27;,
  old_names:[],
  dx: &#x27;generates a specified by the input parameters, alternating warp and weft facing with each input value&#x27;,
  params: [
    &lt;StringParam&gt;{name: &#x27;pattern&#x27;,
    type: &#x27;string&#x27;,
    regex: /(\d+)/,
    value: &#x27;2 2 3 3&#x27;,
    dx: &#x27;the under over pattern of this twill (e.g. 2 2 3 3)&#x27;
    },
    &lt;BoolParam&gt;{name: &#x27;Z/S&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &#x27;Z&#x27;,
    truestate: &#x27;S&#x27;,
    value: 0,
    dx: &#x27;toggle to change twill direction&#x27;
    }
  ],
  inlets: [{
    name: &#x27;shape&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the shape you would like to fill with this twill&#x27;,
    num_drafts: 1
  }],
  perform: (params: Array&lt;ParamValue&gt;, input?: Draft) &#x3D;&gt; {
    const twist &#x3D; params[1];
    const pattern_string: String &#x3D; String(params[0]);
    const sequence: Array&lt;number&gt; &#x3D; pattern_string.split(&#x27; &#x27;).map(el &#x3D;&gt; parseInt(el));

    let sum: number &#x3D; sequence.reduce( (acc, val) &#x3D;&gt; {
      return val + acc;
    }, 0);

    const starting_line: Array&lt;boolean&gt;  &#x3D; [];
    let under &#x3D; true;
    sequence.forEach(input &#x3D;&gt; {
      for (let j &#x3D; 0; j &lt; input; j++) {
        starting_line.push(under);
      }
      under &#x3D; !under;
    });

    const pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];
    let twist_val &#x3D; (twist &#x3D;&#x3D; 0) ? -1 : 1;
    for (let i &#x3D; 0; i &lt; sum; i++) {
      pattern.push([]);
      for (let j &#x3D; 0; j &lt; sum; j++) {
        let ndx &#x3D; (j + (twist_val*i)) % sum;
        if (ndx &lt; 0) ndx &#x3D; sum + ndx;
        pattern[i].push(new Cell(starting_line[ndx]));
      }
    }

    let d: Draft;
    if(!input){
      d &#x3D; initDraftWithParams({warps: sum, wefts: sum, pattern: pattern});
      d.gen_name &#x3D; formatName([], &quot;complex twill&quot;);
    } else {
      d &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
      d.drawdown &#x3D; applyMask(input.drawdown, pattern);         
      // format.transferSystemsAndShuttles(d, [input], params, &#x27;first&#x27;);
      d.gen_name &#x3D; formatName([input], &quot;complex twill&quot;);
    }

    return d; 
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="crop"></a>
                    <span class="name">
                        <span ><b>crop</b></span>
                        <a href="#crop"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;crop&#x27;,
  displayname: &#x27;crop&#x27;,
  old_names: [],
  dx: &#x27;crops to a region of the input draft. The crop size and placement is given by the parameters&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;left&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &#x27;number of pics from the left to start the cut&#x27;
    },
    {name: &#x27;bottom&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &#x27;number of pics from the bottom to start the cut&#x27;
    },
    {name: &#x27;width&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 10000,
    value: 10,
    dx: &#x27;total width of cut&#x27;
    },
    {name: &#x27;height&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 10000,
    value: 10,
    dx: &#x27;height of the cutting box&#x27;
    }
  ],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to crop&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
    const new_warps &#x3D; params[2];
    const new_wefts &#x3D; params[3];

    const d: Draft &#x3D; initDraftWithParams({warps: new_warps, wefts: new_wefts});

    //unset all cells to default
    d.drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {

        if((i+params[1] &gt;&#x3D; input.drawdown.length) || (j+params[0] &gt;&#x3D; input.drawdown[0].length)) cell.setHeddle(null);
        else cell.setHeddle(input.drawdown[i+params[1]][j+params[0]].getHeddle());
        
      });
    });
    // format.transferSystemsAndShuttles(d,[input],params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;crop&quot;);
    return d;
  } 
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="erase_blank"></a>
                    <span class="name">
                        <span ><b>erase_blank</b></span>
                        <a href="#erase_blank"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.NoParams({
  name: &#x27;erase blank rows&#x27;,
  displayname: &#x27;erase blank rows&#x27;,
  old_names:[],
  dx: &#x27;erases any rows that are entirely unset&#x27;,
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to erase blank rows from&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft) &#x3D;&gt; {
    const rows_out &#x3D;input.drawdown.reduce((acc, el, ndx) &#x3D;&gt; {
      if(!utilInstance.hasOnlyUnset(el)) acc++;
      return acc;
    }, 0);

    const out &#x3D; initDraftWithParams({
      wefts: rows_out, warps: warps(input.drawdown), 
      colShuttleMapping:input.colShuttleMapping, 
      colSystemMapping:input.colSystemMapping
    });

    let ndx &#x3D; 0;
    input.drawdown.forEach((row, i) &#x3D;&gt; {
      if(!utilInstance.hasOnlyUnset(row)){
        row.forEach((cell, j) &#x3D;&gt; {
          out.drawdown[ndx][j].setHeddle(cell.getHeddle()); 
        });
        out.rowShuttleMapping[ndx] &#x3D; input.rowShuttleMapping[i];
        out.rowSystemMapping[ndx] &#x3D; input.rowSystemMapping[i];
        out.rowShuttleMapping[ndx] &#x3D;input.rowShuttleMapping[i];
        out.rowSystemMapping[ndx] &#x3D;input.rowSystemMapping[i];
        ndx++;
      }
    })
    return out;        
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="fill"></a>
                    <span class="name">
                        <span ><b>fill</b></span>
                        <a href="#fill"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.NoParams({
  name: &#x27;fill&#x27;,
  displayname: &#x27;fill&#x27;,
  old_names:[],
  dx: &#x27;fills black cells of the first input with the pattern specified by the second input, white cells with third input&#x27;,
  inlets: [{
    name: &#x27;pattern&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft you would like to fill&#x27;,
    num_drafts: 1
  },
  {
    name: &#x27;black cell structure&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the structure you would like to repeat in in the black regions of the base draft&#x27;,
    num_drafts: 1
  },
  {
    name: &#x27;white cell structure&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the structure you would like to repeat in in the white regions of the base draft&#x27;,
    num_drafts: 1
  }],
  perform: (inputs: Array&lt;Draft&gt;) &#x3D;&gt; {
    const base &#x3D; inputs[0];
    const black &#x3D; inputs[1];
    const white &#x3D; inputs[2];

    if (!black &amp;&amp; !white) return base;

    const alldrafts &#x3D; [base, black, white];

    const d &#x3D; initDraftWithParams ({ 
      warps: warps(alldrafts[0].drawdown), 
      wefts:wefts(alldrafts[0].drawdown), 
      pattern:alldrafts[0].drawdown,
      rowShuttleMapping:alldrafts[0].rowShuttleMapping,
      colShuttleMapping:alldrafts[0].colSystemMapping,
      rowSystemMapping:alldrafts[0].rowSystemMapping,
      colSystemMapping:alldrafts[0].colSystemMapping
    });

    for(let i &#x3D; 0; i &lt; wefts(d.drawdown); i++){
      for(let j &#x3D; 0; j &lt; warps(d.drawdown); j++){
        const val &#x3D; d.drawdown[i][j].getHeddle();
        if(val !&#x3D;&#x3D; null){
          if(val &amp;&amp; black !&#x3D;&#x3D; undefined){
            const adj_i &#x3D; i%wefts(alldrafts[1].drawdown);
            const adj_j &#x3D; j%warps(alldrafts[1].drawdown);
            d.drawdown[i][j].setHeddle(alldrafts[1].drawdown[adj_i][adj_j].getHeddle())
          } else if (!val &amp;&amp; white !&#x3D;&#x3D; undefined){
            const adj_i &#x3D; i%wefts(alldrafts[2].drawdown);
            const adj_j &#x3D; j%warps(alldrafts[2].drawdown);
            d.drawdown[i][j].setHeddle(alldrafts[2].drawdown[adj_i][adj_j].getHeddle())
          }
        }
      }
    }    
    return d;
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="flipx"></a>
                    <span class="name">
                        <span ><b>flipx</b></span>
                        <a href="#flipx"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.NoParams({
  name: &#x27;flip horiz&#x27;,
  displayname: &#x27;flip horiz&#x27;,
  old_names:[],
  dx: &#x27;generates an output that is the left-right mirror of the input&#x27;,
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to flip horizontally&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft) &#x3D;&gt; {
    let d: Draft &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
    d.drawdown &#x3D; flipDrawdown(d.drawdown, true);
    // format.transferSystemsAndShuttles(d,[input], {}, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;fhoriz&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="flipy"></a>
                    <span class="name">
                        <span ><b>flipy</b></span>
                        <a href="#flipy"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.NoParams({
  name: &#x27;flip vert&#x27;,
  displayname: &#x27;flip vert&#x27;,
  old_names:[],
  dx: &#x27;generates an output that is the top-bottom mirror of the input&#x27;,
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to flip vertically&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft)&#x3D;&gt; {
    const d: Draft &#x3D;initDraftWithParams({
      warps: warps(input.drawdown), 
      wefts: wefts(input.drawdown), 
      pattern: input.drawdown
    });
    d.drawdown &#x3D; flipDrawdown(d.drawdown, false);
    // format.transferSystemsAndShuttles(d,[input], {}, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;fvert&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="interlace"></a>
                    <span class="name">
                        <span ><b>interlace</b></span>
                        <a href="#interlace"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
  name: &#x27;interlace&#x27;,
  displayname: &#x27;interlace&#x27;,  
  old_names: [],
  dx: &#x27;interlace the input drafts together in alternating lines&#x27;,
  params: &lt;Array&lt;BoolParam&gt;&gt; [
    {name: &#x27;repeat&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &#x27;do not repeat inputs to match size&#x27;,
    truestate: &#x27;repeat inputs to match size&#x27;,
    value: 1,
    dx: &quot;controls if the inputs are interlaced in the exact format submitted (0) or repeated to fill evenly (1)&quot;
  }],
  inlets: [
    {
      name: &#x27;drafts&#x27;, 
      type: &#x27;static&#x27;,
      value: null,
      dx: &#x27;all the drafts you would like to interlace&#x27;,
      num_drafts: -1
    },
    {
      name: &#x27;warp system map&#x27;, 
      type: &#x27;static&#x27;,
      value: null,
      dx: &#x27;if you would like to specify the warp system or materials, you can do so by adding a draft here&#x27;,
      num_drafts: 1
    }
  ],
  perform: (inputs: InletDrafts, params: Array&lt;number&gt;) &#x3D;&gt; {
    const warp_system &#x3D; inputs[1];
    const all_drafts &#x3D; inputs[0];

    let warp_system_draft;
    if (warp_system.length &#x3D;&#x3D; 0) warp_system_draft &#x3D; initDraftWithParams({warps: 1, wefts: 1});
    else  warp_system_draft &#x3D; warp_system[0];

    const factor_in_repeats &#x3D; params[0];

    const d: Draft &#x3D; utilInstance.interlace(all_drafts, factor_in_repeats, warp_system_draft);
  
    // format.transferSystemsAndShuttles(d, all_drafts,params, &#x27;interlace&#x27;);
    // d.gen_name &#x3D; formatName(all_drafts, &quot;ilace&quot;)
    return d;
  }     
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="invert"></a>
                    <span class="name">
                        <span ><b>invert</b></span>
                        <a href="#invert"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.NoParams({
  name: &#x27;invert&#x27;,
  displayname: &#x27;invert&#x27;,
  old_names:[],
  dx: &#x27;generates an output that is the inverse or backside of the input&#x27;,
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to invert&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft) &#x3D;&gt; {
    let d: Draft &#x3D; initDraftWithParams({
      warps: warps(input.drawdown), 
      wefts: wefts(input.drawdown), 
      pattern: input.drawdown});
    d.drawdown &#x3D; invertDrawdown(d.drawdown);
    // format.transferSystemsAndShuttles(d, [input], {}, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;invert&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="joinleft"></a>
                    <span class="name">
                        <span ><b>joinleft</b></span>
                        <a href="#joinleft"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
  name: &#x27;join left&#x27;,
  displayname: &#x27;join left&#x27;,
  old_names:[],
  dx: &#x27;joins drafts together from left to right&#x27;,
  params: [ 
    &lt;BoolParam&gt;{name: &#x27;repeat&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &#x27;do not repeat inputs to match size&#x27;,
    truestate: &#x27;repeat inputs to match size&#x27;,
    value: 1,
    dx: &quot;controls if the inputs are repeated along the width so they repeat in even intervals&quot;
}],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to join horizontally&#x27;,
    num_drafts: -1
  },{
    name: &#x27;weft pattern&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;optional, define a custom weft material or system pattern here&#x27;,
    num_drafts: 1
  }],
  perform: (inputs: InletDrafts, params: Array&lt;number&gt;) &#x3D;&gt; {
    const drafts_in &#x3D; inputs[0];
    const warp_system &#x3D; inputs[1];
    const factor_in_repeats &#x3D; params[0];
    
    let weft_mapping;
    if(warp_system &#x3D;&#x3D;&#x3D; undefined) weft_mapping &#x3D; initDraftWithParams({warps: 1, wefts:1});
    else weft_mapping &#x3D; warp_system[0];

    const all_drafts &#x3D; drafts_in;

    const total_warps:number &#x3D;all_drafts.reduce((acc, draft)&#x3D;&gt;{
        return acc + warps(draft.drawdown);
    }, 0);

    let total_wefts: number &#x3D; 0;
    const all_wefts &#x3D; all_drafts.map(el &#x3D;&gt; wefts(el.drawdown)).filter(el &#x3D;&gt; el &gt; 0);
    if(factor_in_repeats &#x3D;&#x3D;&#x3D; 1) total_wefts &#x3D; utilInstance.lcm(all_wefts);
    else  total_wefts &#x3D; utilInstance.getMaxWefts(all_drafts);


    const d: Draft &#x3D; initDraftWithParams({
      warps: total_warps, 
      wefts: total_wefts,
      rowSystemMapping: weft_mapping.rowSystemMapping,
      rowShuttleMapping: weft_mapping.rowShuttleMapping
    });

    for(let i &#x3D; 0; i &lt; total_wefts; i++){
      const combined_rows: Array&lt;Cell&gt; &#x3D;all_drafts.reduce((acc, input) &#x3D;&gt; {
          let  r: Array&lt;Cell&gt; &#x3D; [];
          //if the draft doesn&#x27;t have this row, just make a blank one
          if(i &gt;&#x3D; wefts(input.drawdown) &amp;&amp; factor_in_repeats &#x3D;&#x3D; 0){
            const nd &#x3D;initDraftWithParams({warps: warps(input.drawdown), wefts: 1});
            nd.drawdown[0].forEach(el &#x3D;&gt; el.setHeddle(null));
            r &#x3D; nd.drawdown[0];
          }
          else {
            r &#x3D;  input.drawdown[i%wefts(input.drawdown)];
          } 
          return acc.concat(r);
        }, []);
        combined_rows.forEach((cell,j) &#x3D;&gt; {
          d.drawdown[i][j].setHeddle(cell.getHeddle());
        });
    }
  
    d.colSystemMapping &#x3D;all_drafts.reduce((acc, draft) &#x3D;&gt; {
      return acc.concat(draft.colSystemMapping);
    }, []);

    d.colShuttleMapping &#x3D; all_drafts.reduce((acc, draft) &#x3D;&gt; {
      return acc.concat(draft.colShuttleMapping);
    }, []);
          

    // format.transferSystemsAndShuttles(d, all_drafts, params, &#x27;joinleft&#x27;);
    d.gen_name &#x3D; formatName(all_drafts, &quot;left&quot;);
    
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="jointop"></a>
                    <span class="name">
                        <span ><b>jointop</b></span>
                        <a href="#jointop"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
  name: &#x27;join top&#x27;,
  displayname: &#x27;join top&#x27;,
  old_names:[],
  dx: &#x27;attachesop_input.drafts toether into one draft in a column orientation&#x27;,
  params: [ 
    &lt;BoolParam&gt;{name: &#x27;repeat&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &#x27;do not repeat inputs to match size&#x27;,
    truestate: &#x27;repeat inputs to match size&#x27;,
    value: 1,
    dx: &quot;controls if the inputs are repeated along the width so they repeat in even intervals&quot;
  }],
  inlets: [{
    name: &#x27;drafts&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the drafts you would like to join vertically&#x27;,
    num_drafts: -1
  },
  {
    name: &#x27;warp pattern&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;optional, define a custom warp material or system pattern here&#x27;,
    num_drafts: -1
  }],
  perform: (inputs: InletDrafts, params: Array&lt;number&gt;) &#x3D;&gt; {
    const drafts_in &#x3D; inputs[0];
    const warp_system &#x3D; inputs[1][0];
    const factor_in_repeats &#x3D; params[0];
    
    let warp_mapping;
    if(warp_system &#x3D;&#x3D;&#x3D; undefined) warp_mapping &#x3D; initDraftWithParams({warps: 1, wefts:1});
    else warp_mapping &#x3D; warp_system;

    const all_drafts &#x3D; drafts_in;

    const total_wefts: number &#x3D; all_drafts.reduce((acc, input)&#x3D;&gt;{
        return acc + wefts(input.drawdown);
    }, 0);

    let total_warps: number &#x3D; 0;
    const all_warps &#x3D; all_drafts.map(el &#x3D;&gt; warps(el.drawdown)).filter(el &#x3D;&gt; el &gt; 0);
    if (factor_in_repeats &#x3D;&#x3D;&#x3D; 1) total_warps &#x3D; utilInstance.lcm(all_warps);
    else  total_warps &#x3D; utilInstance.getMaxWarps(all_drafts);

    const d: Draft &#x3D; initDraftWithParams({
      warps: total_warps, 
      wefts: total_wefts,
      colSystemMapping: warp_mapping.colSystemMapping,
      colShuttleMapping: warp_mapping.colShuttleMapping
    });

    let i &#x3D; 0;
    all_drafts.forEach((input) &#x3D;&gt; {

      input.drawdown.forEach((row, row_ndx) &#x3D;&gt; {
        for(let j &#x3D; 0; j &lt; total_warps; j++){
          const adj_j &#x3D; j % warps(input.drawdown); 
          const repeats &#x3D; Math.floor(j / warps(input.drawdown));
          d.rowShuttleMapping[i] &#x3D; input.rowShuttleMapping[row_ndx];
          d.rowSystemMapping[i] &#x3D; input.rowSystemMapping[row_ndx];
          if (factor_in_repeats) {
            d.drawdown[i][j] &#x3D; new Cell(input.drawdown[row_ndx][adj_j].getHeddle());
          } else {
            if(repeats &#x3D;&#x3D; 0) d.drawdown[i][j] &#x3D; new Cell(input.drawdown[row_ndx][j].getHeddle());
            else d.drawdown[i][j] &#x3D; new Cell(null);
          }
        }
        i++;
      });
    });
    // format.transferSystemsAndShuttles(d, all_drafts, params, &#x27;jointop&#x27;);
    d.gen_name &#x3D; formatName(all_drafts, &quot;top&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="knockout"></a>
                    <span class="name">
                        <span ><b>knockout</b></span>
                        <a href="#knockout"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
  name: &#x27;knockout, (a, b) &#x3D;&gt; (a XOR b)&#x27;,
  displayname: &#x27;knockout, (a, b) &#x3D;&gt; (a XOR b)&#x27;, 
  old_names: [&#x27;knockout&#x27;], 
  dx: &#x27;Flips the value of overlapping cells of the same value, effectively knocking out the image of the second draft upon the first&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;left offset&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &quot;the amount to offset the addedop_input.drafts from the left&quot;
    },
    {name: &#x27;bottom offset&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &quot;the amount to offset the overlayingop_input.drafts from the bottom&quot;
    }
  ],
  inlets: [{
    name: &#x27;a&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;all the drafts you would like to xor another onto&#x27;,
    num_drafts: 1
  },
  {
    name: &#x27;b&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft you would like to xor over the base&#x27;,
    num_drafts: 1
  }],
  perform: (inputs: Array&lt;Draft&gt;, params: Array&lt;number&gt;) &#x3D;&gt; {
    const base &#x3D; inputs[0];
    const top &#x3D; inputs[1];

    if(top &#x3D;&#x3D;&#x3D; undefined) return base;

    const first: Draft &#x3D;inputs.shift();

    let width: number &#x3D; utilInstance.getMaxWarps(inputs) +params[0];
    let height: number &#x3D; utilInstance.getMaxWefts(inputs) +params[1];
    if (warps(first.drawdown) &gt; width) width &#x3D; warps(first.drawdown);
    if (wefts(first.drawdown) &gt; height) height &#x3D; wefts(first.drawdown);

    //initialize the base container with the first draft at 0,0, unset for anythign wider
    const init_draft: Draft &#x3D; initDraftWithParams({wefts: height, warps: width});
        
    first.drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {
        init_draft.drawdown[i][j].setHeddle(cell.getHeddle());
      });
    });

    // now merge in all of the additional op_input.drafts offset by theop_input.drafts

    const d: Draft &#x3D; inputs.reduce((acc, input) &#x3D;&gt; {
      input.drawdown.forEach((row, i) &#x3D;&gt; {
        row.forEach((cell, j) &#x3D;&gt; {
          //if i or j is less than input params 
          const adj_i: number &#x3D; i+params[1];
          const adj_j: number &#x3D; j+params[0];
          acc.drawdown[adj_i][adj_j].setHeddle(utilInstance.computeFilter(&#x27;neq&#x27;, cell.getHeddle(), acc.drawdown[adj_i][adj_j].getHeddle()));
        });
      });
      return acc;

    }, init_draft);
    // format.transferSystemsAndShuttles(d,inputs,params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName(inputs, &quot;ko&quot;);
    return d;
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="layer"></a>
                    <span class="name">
                        <span ><b>layer</b></span>
                        <a href="#layer"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.NoParams({
  name: &#x27;layer&#x27;,
  displayname: &#x27;layer&#x27;,
  old_names: [],
  dx: &#x27;creates a draft in which each input is assigned to a layer in a multilayered structure, assigns 1 to top layer and so on&#x27;,
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the drafts to layer (from top to bottom)&#x27;,
    num_drafts: -1
  }],
  perform: (inputs: Array&lt;Draft&gt;) &#x3D;&gt; {
    const layers &#x3D; inputs.length;

    const all_wefts &#x3D; inputs.map(el &#x3D;&gt; wefts(el.drawdown)).filter(el &#x3D;&gt; el &gt; 0);
    const total_wefts &#x3D; utilInstance.lcm(all_wefts);
  
    const all_warps &#x3D; inputs.map(el &#x3D;&gt; warps(el.drawdown)).filter(el &#x3D;&gt; el &gt; 0);
    const total_warps &#x3D; utilInstance.lcm(all_warps);
  
    const d: Draft &#x3D; initDraftWithParams({warps: total_warps*layers, wefts: total_wefts*layers});
    for (let i &#x3D; 0; i &lt; wefts(d.drawdown); i++) {
      const select_array &#x3D; i % layers;
      const adj_i &#x3D; (Math.floor(i/layers)) % wefts(inputs[select_array].drawdown);
      for(let j &#x3D; 0; j &lt; warps(d.drawdown); j++){
        const adj_j &#x3D; (Math.floor(j/layers)) % warps(inputs[select_array].drawdown);
        if(select_array &#x3D;&#x3D;&#x3D; j % layers){
          d.drawdown[i][j] &#x3D; new Cell (inputs[select_array].drawdown[adj_i][adj_j].getHeddle());
        } else {
          const val &#x3D; (j % layers &lt; select_array) ? true : false;
          d.drawdown[i][j] &#x3D; new Cell(val);
        }
      }
    }
  
    // format.transferSystemsAndShuttles(d, inputs, {}, &#x27;layer&#x27;);
    d.gen_name &#x3D; formatName(inputs, &quot;layer&quot;);
    return d;
  }     
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="makesymmetric"></a>
                    <span class="name">
                        <span ><b>makesymmetric</b></span>
                        <a href="#makesymmetric"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;makesymmetric&#x27;,
  old_names: [],
  displayname: &#x27;make symmetric&#x27;,
  dx: &#x27;rotates the draft around a corner, creating rotational symmetry around the selected point&#x27;,
  params: [
    &lt;SelectParam&gt; {name: &#x27;corner&#x27;,
    type: &#x27;select&#x27;,
    selectlist: [
      {name: &#x27;top left corner&#x27;, value: 0},
      {name: &#x27;top right corner&#x27;, value: 1},
      {name: &#x27;bottom right corner&#x27;, value: 2},
      {name: &#x27;bottom left corner&#x27;, value: 3}
    ],
    value: 0,
    dx: &#x27;corner to which this draft is rotated around 0 is top left, 1 top right, 2 bottom right, 3 bottom left&#x27;
    },
    &lt;BoolParam&gt;{name: &#x27;remove center repeat&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &quot;center repeat kept&quot;,
    truestate: &quot;center repeat removed&quot;,
    value: 0,
    dx: &#x27;rotating drafts creates a repeated set of columns or rows extending from the center. Use this toggle to alternative the structure by either keeping or erasing those repeated cells&#x27;
    }

  ],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to make symmetric&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;ParamValue&gt;) &#x3D;&gt; {
    const corner &#x3D; params[0];
    const even &#x3D; params[1] &#x3D;&#x3D;&#x3D; 0;

    const d &#x3D; input;
    
    const pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];

    let use_i &#x3D; 0;
    let use_j &#x3D; 0;

    let weft_num &#x3D; wefts(d.drawdown) * 2;
    let warp_num &#x3D; warps(d.drawdown) * 2;

    for(let i &#x3D;0; i &lt; weft_num; i++){
      pattern.push([]);
      for(let j &#x3D; 0; j &lt; warp_num; j++){
        switch(corner){
          case 0:
            use_i &#x3D; (i &gt;&#x3D; wefts(d.drawdown)) ? wefts(d.drawdown) - (i - wefts(d.drawdown))-1: i;
            use_j &#x3D; (j &gt;&#x3D; warps(d.drawdown)) ? j - warps(d.drawdown) : warps(d.drawdown)-1 - j; 
          break;

          case 1:
            use_i &#x3D; (i &gt;&#x3D; wefts(d.drawdown)) ? wefts(d.drawdown) - (i - wefts(d.drawdown))-1: i;
            use_j &#x3D; (j &gt;&#x3D; warps(d.drawdown)) ? warps(d.drawdown) - (j - warps(d.drawdown))-1  : j; 
          break;
          

          case 2:
            use_i &#x3D; (i &gt;&#x3D; wefts(d.drawdown)) ? i - wefts(d.drawdown) : wefts(d.drawdown)-1 - i;
            use_j &#x3D; (j &gt;&#x3D; warps(d.drawdown)) ? warps(d.drawdown) - (j - warps(d.drawdown))-1  : j; 
          break;

          case 3:
            use_i &#x3D; (i &gt;&#x3D; wefts(d.drawdown)) ? i - wefts(d.drawdown) : wefts(d.drawdown)-1 - i;
            use_j &#x3D; (j &gt;&#x3D; warps(d.drawdown)) ? j - warps(d.drawdown) : warps(d.drawdown)-1 - j; 
          break;              
        }
        
        const value: boolean &#x3D; d.drawdown[use_i][use_j].getHeddle();
        pattern[i].push(new Cell(value));
      }
    }

    let usepattern; 
    //delete one of the central rows
    if(!even){
      const deletedweft &#x3D; pattern.filter((el, i) &#x3D;&gt; i !&#x3D;&#x3D; wefts(d.drawdown));
      usepattern &#x3D; deletedweft.map(row &#x3D;&gt; row.filter((el, j) &#x3D;&gt; j !&#x3D;&#x3D; warps(d.drawdown)));
    }else{
      usepattern &#x3D; pattern;
    }
  
    const draft: Draft &#x3D; initDraftWithParams({warps: usepattern[0].length, wefts: usepattern.length, pattern: usepattern});
    draft.gen_name &#x3D; formatName([input], &quot;4-way&quot;);
    return draft;

  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="margin"></a>
                    <span class="name">
                        <span ><b>margin</b></span>
                        <a href="#margin"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
  name: &#x27;margin&#x27;,
  displayname: &#x27;add margins&#x27;,
  old_names: [],
  dx: &#x27;adds margins of unset cells, or a user defined draft, to the top, right, bottom, left of the draft&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;starting pics&#x27;,
    min: 0,
    max: 10000,
    value: 12,
    type: &#x27;number&#x27;,
    dx: &#x27;number of pics to add to the bottom of the draft&#x27;
    },
    {name: &#x27;ending pics&#x27;,
    min: 0,
    max: 10000,
    value: 12,
    type: &#x27;number&#x27;,
    dx: &#x27;number of pics to add to the end of the draft&#x27;
    },
    {name: &#x27;starting ends&#x27;,
    min: 0,
    max: 10000,
    value: 12,
    type: &#x27;number&#x27;,
    dx: &#x27;number of ends of padding to the start of the draft&#x27;
    },
    {name: &#x27;ending ends&#x27;,
    min: 0,
    max: 10000,
    value: 12,
    type: &#x27;number&#x27;,
    dx: &#x27;number of ends to add to the end of the draft&#x27;
    }
  ],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to add margins to&#x27;,
    num_drafts: 1
  },
  {
    name: &#x27;margin&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to repeat within the margins&#x27;,
    num_drafts: 1
  }],
  perform: (inputs: Array&lt;Draft&gt;, params: Array&lt;number&gt;) &#x3D;&gt; {
    let main_draft: Draft &#x3D; null;

    if(inputs[0] &#x3D;&#x3D;&#x3D; undefined) main_draft &#x3D; initDraftWithParams({wefts: 0, warps: 0, pattern: [[new Cell(null)]]});
    else main_draft &#x3D; inputs[0];

    const margin_input &#x3D; inputs[1];
    let margin_draft: Draft &#x3D; null;

    if(margin_input &#x3D;&#x3D;&#x3D; undefined) margin_draft &#x3D; initDraftWithParams({wefts: 1, warps: 1, pattern: [[new Cell(null)]]});
    else margin_draft &#x3D; inputs[1];

    const new_warps &#x3D;params[2] +params[3] + warps(inputs[0].drawdown);
    const new_wefts &#x3D;params[0] +params[1] + wefts(inputs[0].drawdown);

    const d: Draft &#x3D;initDraftWithParams({warps: new_warps, wefts: new_wefts, pattern: margin_input.drawdown});


    inputs[0].drawdown.forEach((row, i) &#x3D;&gt; {
        d.rowShuttleMapping[i+params[0]] &#x3D; d.rowShuttleMapping[i];
        d.rowSystemMapping[i+params[0]] &#x3D; d.rowSystemMapping[i];
        row.forEach((cell, j) &#x3D;&gt; {
          d.drawdown[i+params[0]][j+params[3]].setHeddle(cell.getHeddle());
          d.colShuttleMapping[j+params[3]] &#x3D; d.colShuttleMapping[j];
          d.colSystemMapping[j+params[3]] &#x3D; d.colSystemMapping[j];
        });
        
    });
    d.gen_name &#x3D; formatName(inputs, &quot;margin&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="mask"></a>
                    <span class="name">
                        <span ><b>mask</b></span>
                        <a href="#mask"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
  name: &#x27;mask, (a,b) &#x3D;&gt; (a AND b)&#x27;,
  displayname: &#x27;mask, (a,b) &#x3D;&gt; (a AND b)&#x27;,
  old_names:[&#x27;mask&#x27;],
  dx: &#x27;only shows areas of the first draft in regions where the second draft has black/true cells&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;left offset&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &quot;the amount to offset the added op_input.drafts from the left&quot;
    },
    {name: &#x27;bottom offset&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &quot;the amount to offset the overlaying op_input.drafts from the bottom&quot;
    }
  ],
  inlets: [{
    name: &#x27;a&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;all the draft you would like to mask&#x27;,
    num_drafts: 1
  },
  {
    name: &#x27;b&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to use as the mask&#x27;,
    num_drafts: 1
  }],
  perform: (inputs: Array&lt;Draft&gt;, params: Array&lt;number&gt;) &#x3D;&gt; {
    const base &#x3D; inputs[0];
    const top &#x3D; inputs[1];

    if(top &#x3D;&#x3D;&#x3D; undefined) return base;

    const first: Draft &#x3D; inputs.shift();
    const outputs: Array&lt;Draft&gt; &#x3D; [];

    let width: number &#x3D; utilInstance.getMaxWarps(inputs) +params[0];
    let height: number &#x3D; utilInstance.getMaxWefts(inputs) +params[1];
    if(warps(first.drawdown) &gt; width) width &#x3D; warps(first.drawdown);
    if(wefts(first.drawdown) &gt; height) height &#x3D; wefts(first.drawdown);

    //initialize the base container with the first draft at 0,0, unset for anythign wider
    const init_draft: Draft &#x3D; initDraftWithParams({wefts: height, warps: width});
        
    first.drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {
        init_draft.drawdown[i][j].setHeddle(cell.getHeddle());
      });
    });

    //now merge in all of the additional op_input.drafts offset by theop_input.drafts
    const d: Draft &#x3D; inputs.reduce((acc, input) &#x3D;&gt; {
      input.drawdown.forEach((row, i) &#x3D;&gt; {
        row.forEach((cell, j) &#x3D;&gt; {
          //if i or j is less than input params 
          const adj_i: number &#x3D; i+params[1];
          const adj_j: number &#x3D; j+params[0];
          acc.drawdown[adj_i][adj_j].setHeddle(utilInstance.computeFilter(&#x27;and&#x27;, cell.getHeddle(), acc.drawdown[adj_i][adj_j].getHeddle()));
        });
      });
      return acc;

    }, init_draft);
    // format.transferSystemsAndShuttles(d, inputs, params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName(inputs, &quot;mask&quot;)
    return d;
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="number_to_draft"></a>
                    <span class="name">
                        <span ><b>number_to_draft</b></span>
                        <a href="#number_to_draft"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.NoDrafts({
  name: &#x27;number_to_draft&#x27;,
  old_names:[],
  displayname: &#x27;draft by number&#x27;,  
  dx: &#x27;sets the draft values based on a number, turned into binary, and then filled into the structure&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;decode&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100000,
    value: 1,
    dx: &quot;number you&#x27;d like to decode into a draft&quot;
    },
    {name: &#x27;width&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 20,
    value: 5,
    dx: &quot;the width of your structure&quot;
    },
    {name: &#x27;height&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 20,
    value: 5,
    dx: &quot;the height of your structure&quot;
    }
  ],
  perform: (params: Array&lt;number&gt;)&#x3D;&gt; {
    const decode &#x3D; params[0];
    const width &#x3D; params[1];
    const height &#x3D; params[2];

    const bit_size &#x3D; width * height;
    let decode_string &#x3D; decode.toString(2);

    while (decode_string.length &lt; bit_size) {
      decode_string &#x3D; &#x27;0&#x27; + decode_string;
    }

    let pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];
    for (let i &#x3D; 0; i &lt; height; i++) {
      pattern.push([]);
      for (let j &#x3D; 0; j &lt; width; j++) {
        const ndx &#x3D; i * width + j;
        if (ndx &lt; decode_string.length) {
          const cell_val: boolean &#x3D; (decode_string.charAt(ndx) &#x3D;&#x3D; &#x27;1&#x27;);
          pattern[i].push(new Cell(cell_val));
        } else {
          pattern[i].push(new Cell(false));
        }
      }
    }
    
    return initDraftWithParams({wefts: height, warps: width, drawdown: pattern});
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="overlay"></a>
                    <span class="name">
                        <span ><b>overlay</b></span>
                        <a href="#overlay"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
  name: &#x27;overlay, (a,b) &#x3D;&gt; (a OR b)&#x27;,
  displayname: &#x27;overlay, (a,b) &#x3D;&gt; (a OR b)&#x27;, 
  old_names:[&#x27;overlay&#x27;], 
  dx: &#x27;keeps any region that is marked as black/true in either draft&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;left offset&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &quot;the amount to offset b from the left&quot;
    },
    {name: &#x27;bottom offset&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &quot;the amount to offset the overlaying op_input.drafts from the bottom&quot;
    }
  ],
  inlets: [{
    name: &#x27;a&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;all the drafts you would like to overlay another onto&#x27;,
    num_drafts: 1
  },
  {
    name: &#x27;b&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft you would like to overlay onto the base&#x27;,
    num_drafts: 1
  }],
  perform: (inputs: Array&lt;Draft&gt;, params: Array&lt;number&gt;) &#x3D;&gt; {
    const base &#x3D; inputs[0];
    const top &#x3D; inputs[1];

    if(top &#x3D;&#x3D;&#x3D; undefined) return base;

    const alldrafts &#x3D; [base, top];
    const inputs_divided &#x3D; alldrafts.slice();
    const first: Draft &#x3D; inputs_divided.shift();

    const outputs: Array&lt;Draft&gt; &#x3D; [];


    let width: number &#x3D; utilInstance.getMaxWarps(alldrafts) + params[0];
    let height: number &#x3D; utilInstance.getMaxWefts(alldrafts) + params[1];
    if(warps(first.drawdown) &gt; width) width &#x3D; warps(first.drawdown);
    if(wefts(first.drawdown) &gt; height) height &#x3D; wefts(first.drawdown);

    //initialize the base container with the first draft at 0,0, unset for anythign wider
    const init_draft: Draft &#x3D; initDraftWithParams({
      wefts: height, 
      warps: width, 
      colSystemMapping: first.colSystemMapping, 
      colShuttleMapping: first.colShuttleMapping,
      rowSystemMapping: first.rowSystemMapping,
      rowShuttleMapping: first.rowShuttleMapping
    });
      
    first.drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {
        init_draft.drawdown[i][j].setHeddle(cell.getHeddle());
      });
    });

    //now merge in all of the additional op_input.drafts offset by the op_input.drafts
    const d: Draft &#x3D;inputs_divided.reduce((acc, input) &#x3D;&gt; {
      input.drawdown.forEach((row, i) &#x3D;&gt; {
        const adj_i: number &#x3D; i+params[1];

        //if theinitDraftWithParams has only nulls on this row, set the value to the input value
        if(utilInstance.hasOnlyUnset(acc.drawdown[adj_i])){
          acc.rowSystemMapping[adj_i] &#x3D; input.rowSystemMapping[i]
          acc.rowShuttleMapping[adj_i] &#x3D; input.rowShuttleMapping[i]
        }
        row.forEach((cell, j) &#x3D;&gt; {
          //if i or j is less than input params 
          const adj_j: number &#x3D; j+params[0];
          acc.drawdown[adj_i][adj_j].setHeddle(utilInstance.computeFilter(&#x27;or&#x27;, cell.getHeddle(), acc.drawdown[adj_i][adj_j].getHeddle()));
        });
      });
      return acc;

    }, init_draft);

    // format.transferSystemsAndShuttles(d, inputs, params, &#x27;first&#x27;);
    d.gen_name &#x3D; alldrafts.reduce((acc, el) &#x3D;&gt; {
      return acc + &quot;+&quot;+getDraftName(el)
    }, &quot;&quot;).substring(1);
    return d;
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="random"></a>
                    <span class="name">
                        <span ><b>random</b></span>
                        <a href="#random"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.DraftsOptional({
    name: &#x27;random&#x27;,
    displayname: &#x27;random&#x27;,
    old_names: [],
    dx: &#x27;generates a random draft with width, height, and percetage of weft unders defined byop_input.drafts&#x27;,
    params: &lt;Array&lt;NumParam&gt;&gt;[
      {name: &#x27;width&#x27;,
      type: &#x27;number&#x27;,
      min: 1,
      max: 100,
      value: 8,
      dx: &#x27;the width of this structure&#x27;
      },
      {name: &#x27;height&#x27;,
      type: &#x27;number&#x27;,
      min: 1,
      max: 100,
      value: 8,
      dx: &#x27;the height of this structure&#x27;
      },
      {name: &#x27;percent weft unders&#x27;,
      type: &#x27;number&#x27;,
      min: 1,
      max: 100,
      value: 50,
      dx: &#x27;percentage of weft unders to be used&#x27;
      }
    ],
    inlets: [{
      name: &#x27;shape&#x27;, 
      type: &#x27;static&#x27;,
      value: null,
      dx: &#x27;the shape you would like to fill with random&#x27;,
      num_drafts: 1
    }],
    perform: (params: Array&lt;number&gt;, input?: Draft) &#x3D;&gt; {
      const pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];
      for(let i &#x3D; 0; i &lt;params[1]; i++){
        pattern.push([]);
        for(let j &#x3D; 0; j &lt;params[0]; j++){
          const rand: number &#x3D; Math.random() * 100;
          pattern[i][j] &#x3D; (rand &gt;params[2]) ? new Cell(false) : new Cell(true);
        }
      }

      let d: Draft;
      if (input &#x3D;&#x3D;&#x3D; undefined) {
        d &#x3D; initDraftWithParams({warps:params[0], wefts:params[1], pattern: pattern});
        d.gen_name &#x3D; formatName([], &quot;random&quot;);
      } else {
        d &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
        d.drawdown &#x3D; applyMask(input.drawdown, pattern);         
        // format.transferSystemsAndShuttles(d,[input],params, &#x27;first&#x27;);
        d.gen_name &#x3D; formatName([input], &quot;random&quot;);
      }
      return d;
    }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="rect"></a>
                    <span class="name">
                        <span ><b>rect</b></span>
                        <a href="#rect"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.DraftsOptional({
  name: &#x27;rectangle&#x27;,
  displayname: &#x27;rectangle&#x27;,
  old_names: [],
  dx: &#x27;generates a rectangle of the user specified size. If given an input, fills the rectangle with the input&#x27;,
  params: [
    Params.Number({ name: &#x27;width&#x27;, value: 10, min: 1, max: 500, dx: &#x27;width&#x27; }), 
    Params.Number({ name: &#x27;height&#x27;, value: 10, min: 1, max: 500, dx: &#x27;height&#x27; })
  ],
  inlets: [{
    name: &#x27;input draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft with which you would like to fill this rectangle&#x27;,
    num_drafts: 1
  }],
  perform: (params: Array&lt;number&gt;, input?: Draft) &#x3D;&gt; {
    const draft &#x3D; (input !&#x3D;&#x3D; undefined) ? input : initDraftWithParams({drawdown: [[new Cell(true)]]});
    const d: Draft &#x3D; initDraftWithParams({   
      warps: params[0], 
      wefts: params[1], 
      drawdown: draft.drawdown,
      rowShuttleMapping: draft.rowShuttleMapping,
      colShuttleMapping: draft.colShuttleMapping,
      rowSystemMapping: draft.rowSystemMapping,
      colSystemMapping: draft.colSystemMapping
    });
  
    d.gen_name &#x3D; formatName([input], &quot;rect&quot;);      
    return d;
  },
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="replicate"></a>
                    <span class="name">
                        <span ><b>replicate</b></span>
                        <a href="#replicate"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Branch.AllRequired({
  name: &#x27;mirror&#x27;,
  displayname: &#x27;mirror&#x27;,
  old_names: [],
  dx: &#x27;generates an linked copy of the input draft, changes to the input draft will then populate on the replicated draft&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt; [{
    name: &#x27;copies&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 1,
    dx: &#x27;the number of mirrors to produce&#x27;
  }],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to mirror&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
    let outputs: Array&lt;Draft&gt; &#x3D; [];
    for(let i &#x3D; 0; i &lt; params[0]; i++){
      let d: Draft &#x3D; initDraftWithParams({
          warps: warps(input.drawdown), 
          wefts: wefts(input.drawdown), 
          pattern: input.drawdown,
          rowShuttleMapping: input.rowShuttleMapping,
          rowSystemMapping: input.rowSystemMapping,
          colShuttleMapping: input.colShuttleMapping,
          colSystemMapping: input.colSystemMapping
      });
      d.gen_name &#x3D; formatName([input], &quot;mirror&quot;);
      outputs.push(d);
    }
    return outputs;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="resize"></a>
                    <span class="name">
                        <span ><b>resize</b></span>
                        <a href="#resize"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;resize&#x27;,
  displayname: &#x27;resize&#x27;,
  old_names:[],
  dx: &#x27;stretches or squishes the draft to fit the boundary&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;warps&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 10000,
    value: 2,
    dx: &#x27;number of warps to resize to&#x27;
    },
    {name: &#x27;weft repeats&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 10000,
    value: 2,
    dx: &#x27;number of wefts to resize to&#x27;
    }
  ],
  // (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to resize&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
    const weft_factor &#x3D; params[1] / wefts(input.drawdown);
    const warp_factor &#x3D; params[0] / warps(input.drawdown);

    const d: Draft &#x3D; initDraftWithParams({warps:params[0], wefts:params[1]});
    d.drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {
        const mapped_cell: Cell &#x3D; input.drawdown[Math.floor(i/weft_factor)][Math.floor(j/warp_factor)];
        d.drawdown[i][j].setHeddle(mapped_cell.getHeddle());
      });
    });
    // format.transferSystemsAndShuttles(d,[input],params, &#x27;stretch&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;resize&quot;)
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="rib"></a>
                    <span class="name">
                        <span ><b>rib</b></span>
                        <a href="#rib"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.DraftsOptional({
  name: &#x27;rib&#x27;,
  displayname: &#x27;rib&#x27;,
  old_names: [],
  dx: &#x27;generates a rib/cord/half-basket structure defined by the parameters&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {
      name: &#x27;unders&#x27;,
      type: &#x27;number&#x27;,
      min: 1,
      max: 100,
      value: 2,
      dx: &#x27;number of weft unders in a pic&#x27;
    },
    {
      name: &#x27;overs&#x27;,
      type: &#x27;number&#x27;,
      min: 1,
      max: 100,
      value: 2,
      dx: &#x27;number of weft overs in a pic&#x27;
    },
    {
      name: &#x27;repeats&#x27;,
      type: &#x27;number&#x27;,
      min: 1,
      max: 100,
      value: 1,
      dx: &#x27;number of weft pics to repeat within the structure&#x27;
    }
  ],
  inlets: [{
    name: &#x27;shape&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the shape you would like to fill with this rib structure&#x27;,
    num_drafts: 1
  }],
  perform: (params: Array&lt;number&gt;, input?: Draft) &#x3D;&gt; {
  
    const sum: number &#x3D;params[0] + params[1];
    const repeats: number &#x3D; params[2];
    const width: number &#x3D; sum;
    const height: number &#x3D; repeats * 2;

    let alt_rows, alt_cols, val: boolean &#x3D; false;
    const pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];
    for (let i &#x3D; 0; i &lt; height; i++) {
      alt_rows &#x3D; (i &lt; repeats);
      pattern.push([]);
      for (let j &#x3D; 0; j &lt; width; j++) {
        alt_cols &#x3D; (j % sum &lt;params[0]);
        val &#x3D; (alt_cols &amp;&amp; alt_rows) || (!alt_cols &amp;&amp; !alt_rows);
        pattern[i][j] &#x3D;  new Cell(val);
      }
    }

    const d: Draft &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
    d.drawdown &#x3D; applyMask(input.drawdown, pattern);         
    // format.transferSystemsAndShuttles(d, [input], params, &#x27;second&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;rib&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="rotate"></a>
                    <span class="name">
                        <span ><b>rotate</b></span>
                        <a href="#rotate"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;rotate&#x27;,
  displayname: &#x27;rotate&#x27;, 
  old_names:[],     
  dx: &quot;this turns the draft by the amount specified&quot;,
  params: [
    &lt;SelectParam&gt; {
      name: &#x27;amount&#x27;,
      type: &#x27;select&#x27;,
      selectlist: [
        {name: &#x27;90&#x27;, value: 0},
        {name: &#x27;180&#x27;, value: 1},
        {name: &#x27;270&#x27;, value: 2},
      ],
      value: 0,
      dx: &#x27;corner to which this draft is rotated around 0 is top left, 1 top right, 2 bottom right, 3 bottom left&#x27;
    }, &lt;BoolParam&gt; {
      name: &#x27;materials?&#x27;,
      type: &#x27;boolean&#x27;,
      falsestate: &#x27;no, don\&#x27;t rotate materials&#x27;,
      truestate: &#x27;yes, rotate materials&#x27;,
      value: 1, 
      dx: &#x27;if your draft has materials assigned, you can choose wether you want to rotate the draft or the materials only&#x27;
    }
  ],
  inlets: [{
    name: &#x27;input draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft you would like to modify&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;ParamValue&gt;) &#x3D;&gt; {
    const num_rots &#x3D; &lt;number&gt; params[0];
    const rotate_mats &#x3D; (params[1] &#x3D;&#x3D;&#x3D; 0) ? false : true;
    const rotated_wefts &#x3D; ( num_rots % 2 &#x3D;&#x3D; 0) ? warps(input.drawdown) : wefts(input.drawdown);
    const rotated_warps &#x3D; ( num_rots % 2 &#x3D;&#x3D; 0) ? wefts(input.drawdown) : warps(input.drawdown);

    const d: Draft &#x3D; initDraftWithParams({warps: rotated_warps, wefts:rotated_wefts});

    for(var i &#x3D; 0; i &lt; wefts(input.drawdown); i++){
      for(var j &#x3D; 0; j &lt; warps(input.drawdown); j++){
        const heddle_val &#x3D; input.drawdown[i][j].getHeddle();
        switch (num_rots) {
          case 0: 
            d.drawdown[(warps(input.drawdown) - 1) - j][i].setHeddle(heddle_val);
            break;
          case 1: 
            d.drawdown[(wefts(input.drawdown) - 1) - i][(warps(input.drawdown) - 1) - j].setHeddle(heddle_val);            
            break;
          case 2: 
            d.drawdown[j][(wefts(input.drawdown) - 1)  - i].setHeddle(heddle_val);
            break;
        }
      }
    }

    if (rotate_mats) {
      for (var i &#x3D; 0; i &lt; wefts(input.drawdown); i++) {
        switch(num_rots) {
          case 0: 
            d.colShuttleMapping[i] &#x3D; input.rowShuttleMapping[i];
            d.colSystemMapping[i] &#x3D; input.rowSystemMapping[i];
            break;
          case 1: 
            d.rowShuttleMapping[(wefts(input.drawdown) - 1) - i] &#x3D; input.rowShuttleMapping[i];
            d.rowSystemMapping[(wefts(input.drawdown) - 1) - i] &#x3D; input.rowSystemMapping[i];         
            break;
          case 2: 
            d.colShuttleMapping[wefts(input.drawdown)-1-i] &#x3D; input.rowShuttleMapping[i];
            d.colSystemMapping[wefts(input.drawdown)-1-i] &#x3D; input.rowSystemMapping[i];
            break;
        }
          
        for(var j &#x3D; 0; j &lt; warps(input.drawdown); j++){
          switch(num_rots){
            case 0: 
              d.rowShuttleMapping[j] &#x3D;  input.colShuttleMapping[j];
              d.rowSystemMapping[j] &#x3D; input.colSystemMapping[j];
              break;
            case 1: 
              
              d.colShuttleMapping[(warps(input.drawdown) - 1) - j] &#x3D;  input.colShuttleMapping[j];
              d.colSystemMapping[(warps(input.drawdown) - 1) - j] &#x3D; input.colSystemMapping[j];

              break;
            case 2: 

              d.rowShuttleMapping[(warps(input.drawdown) - 1)  - j] &#x3D;  input.colShuttleMapping[j];
              d.rowSystemMapping[(warps(input.drawdown) - 1)  - j] &#x3D; input.colSystemMapping[j];
        
              break;

          }
        }
      }
    } else {
      for (var i &#x3D; 0; i &lt; wefts(d.drawdown); i++) {
        d.rowShuttleMapping[i] &#x3D; input.rowShuttleMapping[i];
        d.rowSystemMapping[i] &#x3D; input.rowSystemMapping[i];
      }
      for(var j &#x3D; 0; j &lt; warps(d.drawdown); j++){
        d.colShuttleMapping[j] &#x3D; input.colShuttleMapping[j];
        d.colSystemMapping[j] &#x3D; input.colSystemMapping[j];
      }
    }
    d.gen_name &#x3D; formatName([input], &quot;rot&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="satin"></a>
                    <span class="name">
                        <span ><b>satin</b></span>
                        <a href="#satin"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.DraftsOptional({
  name: &#x27;satin&#x27;,
  displayname: &#x27;satin&#x27;,
  old_names:[],
  dx: &#x27;generates or fills with a satin structure described by the input parameters&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;repeat&#x27;,
    type: &#x27;number&#x27;,
    min: 5,
    max: 100,
    value: 5,
    dx: &#x27;the width and height of the pattern&#x27;
    },
    {name: &#x27;move&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 2,
    dx: &#x27;the move number on each row&#x27;
    },
    &lt;BoolParam&gt;{name: &#x27;face&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &quot;weft facing&quot;,
    truestate: &quot;warp facing&quot;,
    value: 0,
    dx: &#x27;select to toggle warp and weft facing variations of this satin&#x27;
    }
  ],
  inlets: [{
    name: &#x27;shape&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the shape you would like to fill with tabby&#x27;,
    num_drafts: 1
  }],
  perform: (params: Array&lt;number&gt;, input?: Draft) &#x3D;&gt; {
    const pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];
    for(let i &#x3D; 0; i &lt;params[0]; i++){
      pattern.push([]);
      for(let j &#x3D; 0; j &lt;params[0]; j++){
        if(params[2]&#x3D;&#x3D;&#x3D; 0) pattern[i][j] &#x3D; (j&#x3D;&#x3D;&#x3D;(i*params[1])%params[0]) ? new Cell(true) : new Cell(false);
        else pattern[i][j] &#x3D; (j&#x3D;&#x3D;&#x3D;(i*params[1])%params[0]) ? new Cell(false) : new Cell(true);
      }
    }

    let d: Draft;
    if(input &#x3D;&#x3D;&#x3D; undefined){
      d &#x3D; initDraftWithParams({warps:params[0], wefts:params[0], pattern: pattern});
      d.gen_name &#x3D; formatName([], &quot;satin&quot;);
    } else {
      d &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
      d.drawdown &#x3D; applyMask(input.drawdown, pattern);         
      // format.transferSystemsAndShuttles(d,[input],params, &#x27;first&#x27;);
      d.gen_name &#x3D; formatName([input], &quot;satin&quot;);
    }
    return d;
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="selvedge"></a>
                    <span class="name">
                        <span ><b>selvedge</b></span>
                        <a href="#selvedge"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
  name: &#x27;selvedge&#x27;,
  old_names: [],
  displayname: &#x27;selvedge&#x27;,  
  dx: &#x27;adds a selvedge of a user defined width (in ends) on both sides of the input draft. The second input functions as the selvedge pattern, and if none is selected, a selvedge is generated&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;width&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 12,
    dx: &quot;the width in warps of the selvedge&quot;
    }
  ],
  inlets: [
    {
      name: &#x27;draft&#x27;,
      type: &#x27;static&#x27;,
      value: null,
      dx: &quot;the draft that will have a selvedge added&quot;,
      num_drafts: 1
    },
    {
      name: &#x27;selvedge&#x27;,
      type: &#x27;static&#x27;,
      value: null,
      dx: &quot;the pattern to use for the selvedge&quot;,
      num_drafts: 1
    }
  ],
  perform: (inputs: Array&lt;Draft&gt;, params: Array&lt;number&gt;)&#x3D;&gt; {

    const draft_input &#x3D; inputs[0];
    const selvedge_input &#x3D; inputs[1];

    if(selvedge_input &#x3D;&#x3D;&#x3D; undefined) return draft_input;

    const num_systems &#x3D; utilInstance.filterToUniqueValues(draft_input.rowSystemMapping).length;
    const height &#x3D; 2 * num_systems;

    let pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];

    if (selvedge_input !&#x3D;&#x3D; undefined) {
      pattern &#x3D; selvedge_input.drawdown;
    } else {
      for(let i &#x3D; 0; i &lt; height; i++){
        pattern.push([]);
        let alt: boolean &#x3D;  i &lt; num_systems;
        for (let j &#x3D; 0; j &lt; 2; j++) {
          pattern[i][j] &#x3D; ((alt &amp;&amp; j%2 &#x3D;&#x3D;0) || (!alt &amp;&amp; j%2 &#x3D;&#x3D;1)) ? new Cell(true) : new Cell(false);
        }
      }
    }

    const input: Draft &#x3D; inputs[0];
    const d: Draft &#x3D; initDraftWithParams({warps: warps(input.drawdown) +params[0]*2, wefts: wefts(input.drawdown)});
        
    for (let i &#x3D; 0; i &lt; wefts(d.drawdown); i++) {
      for (let j &#x3D; 0; j &lt; warps(d.drawdown); j++) {
        if (j &lt; params[0]) {
          //left selvedge
          d.drawdown[i][j].setHeddle(pattern[i%pattern.length][j%pattern[0].length].getHeddle());

        } else if (j &lt; params[0]+warps(input.drawdown)) {
          //pattern
          d.drawdown[i][j].setHeddle(input.drawdown[i][j - params[0]].getHeddle());

        } else {
          //right selvedge
          d.drawdown[i][j].setHeddle(pattern[i%pattern.length][j%pattern[0].length].getHeddle());

        }
      }
    }
    // format.transferSystemsAndShuttles(d, inputs, params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName(inputs, &quot;sel&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="set"></a>
                    <span class="name">
                        <span ><b>set</b></span>
                        <a href="#set"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;set unset&#x27;,
  displayname: &#x27;set unset heddle to&#x27;,
  old_names: [&#x27;unset&#x27;],
  dx: &quot;this sets all unset heddles in this draft to the specified value&quot;,
  params: &lt;Array&lt;BoolParam&gt;&gt; [ 
    {name: &#x27;up/down&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &#x27;unset to heddle up&#x27;,
    truestate: &#x27;unset to heddle down&#x27;,
    value: 1,
    dx: &quot;toggles the value to which to set the unset cells (heddle up or down)&quot;
  }],
  inlets: [{
    name: &#x27;input draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft you would like to modify&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;number&gt;)&#x3D;&gt; {       
    const d: Draft &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown)});
    input.drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {
        if(!cell.isSet()){
          if(params[0] &#x3D;&#x3D;&#x3D; 0) d.drawdown[i][j] &#x3D; new Cell(false);
          else d.drawdown[i][j] &#x3D; new Cell(true);
        } 
        else d.drawdown[i][j] &#x3D; new Cell(cell.isUp());
      });
    });
    // format.transferSystemsAndShuttles(d, [input], params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;unset-&gt;down&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="shaded_satin"></a>
                    <span class="name">
                        <span ><b>shaded_satin</b></span>
                        <a href="#shaded_satin"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.NoDrafts({
  name: &#x27;shaded_satin&#x27;,
  displayname: &#x27;shaded satin&#x27;,
  old_names: [],
  dx: &#x27;generates or fills with a satin structure described by the input parameters&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;warps raised&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 100,
    value: 2,
    dx: &#x27;the number of warps to raise on the first pic&#x27;
    },
    {name: &#x27;warps lowered&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 100,
    value: 5,
    dx: &#x27;the number of warps to keep lowered on the first pic&#x27;
    },
    {name: &#x27;offset&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 2,
    dx: &#x27;amount to offset the interlacements on each row&#x27;
    },
    &lt;BoolParam&gt;{name: &#x27;face&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &quot;weft facing&quot;,
    truestate: &quot;warp facing&quot;,
    value: 0,
    dx: &#x27;select to toggle warp and weft facing variations of this satin&#x27;
    }
  ],
  perform: (params: Array&lt;number&gt;) &#x3D;&gt; {
    
    const lift &#x3D; params[0];
    const lowered &#x3D; params[1];
    const shift &#x3D; params[2];
    const weft_face &#x3D; params[3];

    const repeat &#x3D; lift+lowered;

    let first_pic: Array&lt;Cell&gt; &#x3D; [];
    for(let i &#x3D; 0; i &lt; repeat; i++){
      if(i &lt; lift) first_pic.push(new Cell(true));
      else first_pic.push(new Cell(false));
    }

    if(weft_face &#x3D;&#x3D; 1) first_pic &#x3D; first_pic.map(el &#x3D;&gt; {
      if(el.getHeddle() &#x3D;&#x3D; true) return new Cell(false);
      else return new Cell(true);
    });

    const d: Draft &#x3D; initDraftWithParams({warps:repeat, wefts:repeat});

    for(let i &#x3D; 0; i &lt; repeat; i++){
      for(let j &#x3D; 0; j &lt; repeat; j++){
        let shift_j &#x3D;  (j+ (shift * i)) % repeat;
        d.drawdown[i][j].setHeddle(first_pic[shift_j].getHeddle());
      }
    }
    
    d.gen_name &#x3D; formatName([], &quot;satin&quot;);
    return d;
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="shiftx"></a>
                    <span class="name">
                        <span ><b>shiftx</b></span>
                        <a href="#shiftx"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;shift left&#x27;,
  displayname: &#x27;shift left&#x27;,
  old_names:[],
  dx: &#x27;generates an output that is shifted left by the number of warps specified in theop_input.drafts&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;amount&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 1,
    dx: &#x27;the amount of warps to shift by&#x27;
    }
  ],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to shift&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
    const d: Draft &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
    d.drawdown &#x3D; shiftDrawdown(d.drawdown, false, params[0]);
    // format.transferSystemsAndShuttles(d, [input], params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;shiftx&quot;);
  
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="shifty"></a>
                    <span class="name">
                        <span ><b>shifty</b></span>
                        <a href="#shifty"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;shift up&#x27;,
  displayname: &#x27;shift up&#x27;,
  old_names:[],
  dx: &#x27;generates an output that is shifted up by the number of wefts specified in theop_input.drafts&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;amount&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 1,
    dx: &#x27;the number of wefts to shift by&#x27;
    }
  ],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to shift&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
    const d: Draft &#x3D;initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
    d.drawdown &#x3D; shiftDrawdown(d.drawdown, true, params[0]);
    // format.transferSystemsAndShuttles(d,[input],params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;shifty&quot;);
  
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="slope"></a>
                    <span class="name">
                        <span ><b>slope</b></span>
                        <a href="#slope"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;slope&#x27;,
  displayname: &#x27;slope&#x27;,
  old_names:[],
  dx: &#x27;offsets every nth row by the vaule given in col&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;col shift&#x27;,
    type: &#x27;number&#x27;,
    min: -100,
    max: 100,
    value: 1,
    dx: &#x27;the amount to shift rows by&#x27;
    },
    {
    name: &#x27;row shift (n)&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 100,
    value: 1,
    dx: &#x27;describes how many rows we should apply the shift to&#x27;
    }
  ],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to slope&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
    const d: Draft &#x3D;initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown)});
    for(let i &#x3D; 0; i &lt; wefts(d.drawdown); i++){
      let i_shift: number &#x3D; (params[1] &#x3D;&#x3D;&#x3D; 0) ? 0 : Math.floor(i/params[1]);
      for(let j &#x3D; 0; j &lt;warps(d.drawdown); j++){
        let j_shift: number &#x3D;params[0]*-1;
        let shift_total &#x3D; (i_shift * j_shift)%warps(d.drawdown);
        if(shift_total &lt; 0) shift_total +&#x3D; warps(d.drawdown);
        d.drawdown[i][j].setHeddle(input.drawdown[i][(j+shift_total)%warps(d.drawdown)].getHeddle());
      }
    }
    // format.transferSystemsAndShuttles(d,[input],params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;slope&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="stretch"></a>
                    <span class="name">
                        <span ><b>stretch</b></span>
                        <a href="#stretch"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;stretch&#x27;,
  displayname: &#x27;stretch&#x27;,
  old_names:[],
  dx: &#x27;repeats each warp and/or weft by theop_input.drafts&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;warp repeats&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 1,
    dx: &#x27;number of times to repeat each warp&#x27;
    },
    {name: &#x27;weft repeats&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 2,
    dx: &#x27;number of weft overs in a pic&#x27;
    }
  ],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to stretch&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
    const d: Draft &#x3D; initDraftWithParams({warps: params[0]*warps(input.drawdown), wefts:params[1]*wefts(input.drawdown)});
    input.drawdown.forEach((row, i) &#x3D;&gt; {
      for (let p &#x3D; 0; p &lt; params[1]; p++) {
        let i_ndx &#x3D; params[1] * i + p;
        row.forEach((cell, j) &#x3D;&gt; {
          for (let r &#x3D; 0; r &lt; params[0]; r++) {
            let j_ndx &#x3D;params[0] * j + r;
            d.drawdown[i_ndx][j_ndx].setHeddle(cell.getHeddle());
          }
        });
      }
    });
    // format.transferSystemsAndShuttles(d,[input], params, &#x27;stretch&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;stretch&quot;)
    return d; 
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="tabby"></a>
                    <span class="name">
                        <span ><b>tabby</b></span>
                        <a href="#tabby"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.DraftsOptional({
  name: &#x27;tabby&#x27;,
  displayname: &#x27;tabby&#x27;,
  old_names: [],
  dx: &#x27;also known as plain weave generates or fills input a draft with tabby structure or derivitae&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;repeats&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 1,
    dx: &#x27;the number or reps to adjust evenly through the structure&#x27;
    },
  ],
  inlets: [{
    name: &#x27;shape&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the shape you would like to fill with tabby&#x27;,
    num_drafts: 1
  }],
  perform: (params: Array&lt;number&gt;, input?: Draft) &#x3D;&gt; {
    const width: number &#x3D; params[0]*2;
    const height: number &#x3D; params[0]*2;

    let alt_rows, alt_cols, val: boolean &#x3D; false;
    const pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];
    for(let i &#x3D; 0; i &lt; height; i++){
      alt_rows &#x3D; (i &lt; params[0]);
      pattern.push([]);
      for(let j &#x3D; 0; j &lt; width; j++){
        alt_cols &#x3D; (j &lt; params[0]);
        val &#x3D; (alt_cols &amp;&amp; alt_rows) || (!alt_cols &amp;&amp; !alt_rows);
        pattern[i][j] &#x3D;  new Cell(val);
      }
    }

    if (!input) {
      const d: Draft &#x3D; initDraftWithParams({warps: width, wefts: height, pattern: pattern});
      d.gen_name &#x3D; formatName([], &quot;tabby&quot;);
      return d;
    } else {
      const d: Draft &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
      d.drawdown &#x3D; applyMask(input.drawdown, pattern);         
      // format.transferSystemsAndShuttles(d, [input], params, &#x27;first&#x27;);
      d.gen_name &#x3D; formatName([input], &quot;tabby&quot;)
      return d;
    }
  }
})</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>************ BASIC OPERATIONS *********************</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="tabby_der"></a>
                    <span class="name">
                        <span ><b>tabby_der</b></span>
                        <a href="#tabby_der"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.NoDrafts({
  name: &#x27;tabbyder&#x27;,
  displayname: &#x27;tabby&#x27;,
  old_names: [],
  dx: &#x27;also known as plain weave generates or fills input a draft with tabby structure or derivative&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;warps raised&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 100,
    value: 1,
    dx: &#x27;the number of warp ends to have lifted in the first pic&#x27;
    },
    {name: &#x27;warps lowered&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 100,
    value: 1,
    dx: &#x27;the number of warp ends to keep lowered in the first tabby pic&#x27;
    },
    {name: &#x27;pics&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 100,
    value: 1,
    dx: &#x27;the number of pics upon which the first tabby pic will be repeated&#x27;
    },
    {
      name: &#x27;alt pics&#x27;,
      type: &#x27;number&#x27;,
      min: 0,
      max: 100,
      value: 1,
      dx: &#x27;the number of pics upon which the repeat the alteranting pattern&#x27;
    },
  ],
  perform: (params: Array&lt;number&gt;) &#x3D;&gt; {

    const raised: number &#x3D; params[0];
    const lowered: number &#x3D; params[1];
    const rep: number &#x3D; params[2];
    const alt_rep: number &#x3D; params[3];

    const d: Draft &#x3D; initDraftWithParams({warps: raised + lowered, wefts: rep+alt_rep});

    for (let i &#x3D; 0; i &lt; warps(d.drawdown); i++) {
      if(i &lt; raised) d.drawdown[0][i].setHeddle(true);
      else d.drawdown[0][i].setHeddle(false);
    }

    for(let i &#x3D; 1; i &lt; wefts(d.drawdown); i++){
      if(i &lt; rep) d.drawdown[i] &#x3D; d.drawdown[0].slice();
      else{
        for(let j &#x3D; 0; j &lt; warps(d.drawdown); j++){
          d.drawdown[i][j].setHeddle(!d.drawdown[0][j].getHeddle());
        }
      } 
    }
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="tile"></a>
                    <span class="name">
                        <span ><b>tile</b></span>
                        <a href="#tile"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Merge.AllRequired({
  name: &#x27;tile&#x27;,
  displayname: &#x27;tile&#x27;,
  dx: &#x27;repeats one or more input drafts along the warp and weft&#x27;,
  old_names: [],
  params: &lt;Array&lt;NumParam&gt;&gt; [
    {name: &#x27;warp-repeats&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 2,
    dx: &#x27;the number of times to repeat this time across the width&#x27;
    },
    {name: &#x27;weft-repeats&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 2,
    dx: &#x27;the number of times to repeat this time across the length&#x27;
    }
  ],
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the drafts to tile&#x27;,
    num_drafts: -1
  }],
  perform: (inputs: Array&lt;Draft&gt;, params: Array&lt;number&gt;) &#x3D;&gt; {
    const all_drafts &#x3D; inputs;

    const all_warps &#x3D; all_drafts.map(el &#x3D;&gt; warps(el.drawdown)).filter(el &#x3D;&gt; el &gt; 0);
    const total_warps &#x3D; utilInstance.lcm(all_warps);

    const all_wefts &#x3D; all_drafts.map(el &#x3D;&gt; wefts(el.drawdown)).filter(el &#x3D;&gt; el &gt; 0);
    const total_wefts &#x3D; utilInstance.lcm(all_wefts);
    const num_inputs &#x3D; all_drafts.length;

    const warp_repeats &#x3D; params[0];
    const weft_repeats &#x3D; params[1];

    const draft_indexing: Array&lt;Array&lt;number&gt;&gt; &#x3D; [];
    let ndx &#x3D; 0;
    for (let i &#x3D; 0; i &lt; weft_repeats; i++) {
      draft_indexing.push([]);
      for(let j &#x3D; 0; j &lt; warp_repeats; j++){
        draft_indexing[i].push(ndx);
        ndx &#x3D; (ndx + 1 ) % num_inputs;
      }
    }

    const width: number &#x3D; warp_repeats*total_warps;
    const height: number &#x3D; weft_repeats*total_wefts;
    const output: Draft &#x3D; initDraftWithParams({warps: width, wefts: height});

    output.drawdown.forEach((row, i) &#x3D;&gt; {
      let draft_index_row  &#x3D; Math.floor(i / total_wefts);
      let within_draft_row &#x3D; i % total_wefts;
      row.forEach((cell, j) &#x3D;&gt; {
        let draft_index_col  &#x3D; Math.floor(j / total_warps);
        let within_draft_col  &#x3D; j % total_warps;
        const select_draft_id &#x3D; draft_indexing[draft_index_row][draft_index_col];

        const draft &#x3D; all_drafts[select_draft_id];
        const w &#x3D; warps(draft.drawdown);
        const h &#x3D; wefts(draft.drawdown);
        cell.setHeddle(draft.drawdown[within_draft_row%w][within_draft_col%h].getHeddle()); 
      });
    });
    
    // format.transferSystemsAndShuttles(output, all_drafts, params, &#x27;first&#x27;);
    output.gen_name &#x3D; formatName(all_drafts, &quot;tile&quot;);
  
    return output;
  }   
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="trim"></a>
                    <span class="name">
                        <span ><b>trim</b></span>
                        <a href="#trim"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;trim&#x27;,
  displayname: &#x27;trim&#x27;,
  old_names: [],
  dx: &#x27;trims off the edges of an input draft&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;left&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 10000,
    value: 0,
    dx: &#x27;number of warps from the left to start the cut&#x27;
    },
    { name: &#x27;top&#x27;,
      type: &#x27;number&#x27;,
      min: 0,
      max: 10000,
      value: 0,
      dx: &#x27;number of pics from the top to start the cut&#x27;
    },
    { name: &#x27;right&#x27;,
      type: &#x27;number&#x27;,
      min: 0,
      max: 10000,
      value: 0,
      dx: &#x27;number of warps from the right to start the cut&#x27;
    },
    { name: &#x27;bottom&#x27;,
      type: &#x27;number&#x27;,
      min: 0,
      max: 10000,
      value: 0,
      dx: &#x27;number of pics from the bottom to start the cut&#x27;
    }
  ],
  // perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to trim&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;number&gt;) &#x3D;&gt; {
    const left &#x3D; params[0];
    const top &#x3D; params[3];
    const right &#x3D; params[2];
    const bottom &#x3D; params[1];
    
    let new_warps &#x3D; warps(input.drawdown) - right - left;
    if(new_warps &lt; 0) new_warps &#x3D; 0;

    let new_wefts &#x3D; wefts(input.drawdown) - top - bottom;
    if(new_wefts &lt; 0) new_wefts &#x3D; 0;

    const d: Draft &#x3D; initDraftWithParams({warps: new_warps, wefts: new_wefts});

    d.drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {
        cell.setHeddle(input.drawdown[i+top][j+left].getHeddle());                             
      });
    });
    // format.transferSystemsAndShuttles(d,[input],params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;trim&quot;);
    return d;
  }     
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="twill"></a>
                    <span class="name">
                        <span ><b>twill</b></span>
                        <a href="#twill"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.DraftsOptional({
  name: &#x27;twill&#x27;,
  displayname: &#x27;twill&#x27;,
  old_names: [],
  dx: &#x27;generates or fills with a twill structure described by the input drafts&#x27;,
  params: [
    &lt;NumParam&gt; {name: &#x27;warps raised&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 1,
    dx: &#x27;number of warps raised in the first pic&#x27;
    },
    &lt;NumParam&gt;{name: &#x27;warps lowered&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 3,
    dx: &#x27;number of warps reaminig lowered in the first pic&#x27;
    },
    &lt;BoolParam&gt; {name: &#x27;Z/S&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &#x27;S&#x27;,
    truestate: &#x27;Z&#x27;,
    value: 0,
    dx: &#x27;toggle to switch the twist direction&#x27;
    },
    &lt;BoolParam&gt; {name: &#x27;face&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &quot;weft facing&quot;,
    truestate: &quot;warp facing&quot;,
    value: 0,
    dx: &#x27;select to toggle warp and weft facing variations of this satin&#x27;
    }
  ],
  inlets: [{
    name: &#x27;shape&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the shape you would like to fill with twill&#x27;,
    num_drafts: 1
  }],
  perform: (params: Array&lt;number&gt;, input?: Draft) &#x3D;&gt; {
   
    let sum: number &#x3D; params[0] + params[1];

   // sum -&#x3D;params[2];

    const pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];
    for(let i &#x3D; 0; i &lt; sum; i++){
      pattern.push([]);
      for(let j &#x3D; 0; j &lt; sum; j++){
        if (params[3] &#x3D;&#x3D; 0) pattern[i][(j+i)%sum] &#x3D; (j &lt; params[0]) ? new Cell(true) : new Cell(false);
        else pattern[i][(j+i)%sum] &#x3D; (j &lt; params[0]) ? new Cell(false) : new Cell(true);
      }
    }

    let d: Draft;
    if (!input) {
      d &#x3D; initDraftWithParams({warps: sum, wefts: sum, pattern: pattern});
      d.gen_name &#x3D; formatName([], &quot;twill&quot;);
    } else {
      d &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
      d.drawdown &#x3D; applyMask(input.drawdown, pattern);         
      // format.transferSystemsAndShuttles(d, [input], params, &#x27;first&#x27;);
      d.gen_name &#x3D; formatName([input], &quot;twill&quot;);
    }

    if (params[2] &#x3D;&#x3D;&#x3D; 1) {
      return flipx.perform(d);
      //return (&lt;Operation&gt;this.getOp(&#x27;flip horiz&#x27;)).perform([{drafts:[], params:[], inlet: 0, op_name:&quot;flip horiz&quot;}, {drafts:outputs, params:[], inlet: 0, op_name:&quot;child&quot;}]);
    } else {
      return d;
    }
  }        
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="unset"></a>
                    <span class="name">
                        <span ><b>unset</b></span>
                        <a href="#unset"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Pipe.AllRequired({
  name: &#x27;set down to unset&#x27;,
  displayname: &#x27;set heddles of type to unset&#x27;,
  old_names: [&#x27;set&#x27;],
  dx: &quot;this sets all  heddles of a particular type in this draft to unset&quot;,
  params: &lt;Array&lt;BoolParam&gt;&gt; [{
    name: &#x27;up/down&#x27;,
    type: &#x27;boolean&#x27;,
    falsestate: &#x27;heddle up to unset&#x27;,
    truestate: &#x27;heddle down to unset&#x27;,
    value: 1,
    dx: &quot;toggles which values to map to unselected&quot;
  }],
  inlets: [{
    name: &#x27;input draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft you would like to modify&#x27;,
    num_drafts: 1
  }],
  perform: (input: Draft, params: Array&lt;ParamValue&gt;) &#x3D;&gt; {
    const d: Draft &#x3D;initDraftWithParams({warps: warps(input.drawdown), wefts:wefts(input.drawdown)});
    input.drawdown.forEach((row, i) &#x3D;&gt; {
      row.forEach((cell, j) &#x3D;&gt; {
        if(params[0] &#x3D;&#x3D;&#x3D; 1 &amp;&amp; !cell.isUp() &amp;&amp; cell.isSet()) d.drawdown[i][j] &#x3D; new Cell(null);
        else if(params[0] &#x3D;&#x3D;&#x3D; 0 &amp;&amp; cell.isUp() &amp;&amp; cell.isSet()) d.drawdown[i][j] &#x3D; new Cell(null);
        else d.drawdown[i][j] &#x3D; new Cell(cell.getHeddle());
      });
    });
    
    // format.transferSystemsAndShuttles(d, [input], params, &#x27;first&#x27;);
    d.gen_name &#x3D; formatName([input], &quot;unset&quot;);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name=""></a>
                    <span class="name">
                        <span ><b></b></span>
                        <a href="#"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>OpFactories</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="variants"></a>
                    <span class="name">
                        <span ><b>variants</b></span>
                        <a href="#variants"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Branch.NoParams({
  name: &#x27;variants&#x27;,
  displayname: &#x27;variants&#x27;,
  old_names:[],
  dx: &#x27;for any input draft, create the shifted and flipped values as well&#x27;,
  inlets: [{
    name: &#x27;draft&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the draft to create varients of&#x27;,
    num_drafts: 1
  }], 
  perform: (input: Draft) &#x3D;&gt; {
    const functions: Array&lt;Draft&gt; &#x3D; [
      flipx.perform(input),
      invert.perform(input)
    ];

    for (let i &#x3D; 1; i &lt; warps(input.drawdown); i +&#x3D; 2) {
      functions.push(shiftx.perform(input, [i]));
    }

    for (let i &#x3D; 1; i &lt; wefts(input.drawdown); i +&#x3D; 2) {
      functions.push(shifty.perform(input, [i]));
    }
    return functions;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="waffle"></a>
                    <span class="name">
                        <span ><b>waffle</b></span>
                        <a href="#waffle"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>Seed.DraftsOptional({
  name: &#x27;waffle&#x27;,
  displayname: &#x27;waffle-ish&#x27;,
  old_names: [],
  dx: &#x27;generates or fills with a waffle structure, sometimes, and some other funky structures at others&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt;[
    {name: &#x27;ends&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 8,
    dx: &#x27;the number of ends to be used in the waffle&#x27;
    },
    {name: &#x27;pics&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 8,
    dx: &#x27;the number of pics to use in the waffle&#x27;
    },
    {name: &#x27;interlacement rows&#x27;,
    type: &#x27;number&#x27;,
    min: 0,
    max: 100,
    value: 1,
    dx: &#x27;builds tabby around the edges of the central diamond, creating some strange patterns&#x27;
    }
  ],
  inlets: [{
    name: &#x27;shape&#x27;, 
    type: &#x27;static&#x27;,
    value: null,
    dx: &#x27;the shape you would like to fill with waffle&#x27;,
    num_drafts: 1
  }],
  perform: (params: Array&lt;number&gt;, input?: Draft) &#x3D;&gt; {

    const width &#x3D; params[0];
    const height &#x3D; params[1];
    const bindings &#x3D; params[2];

    const pattern: Array&lt;Array&lt;Cell&gt;&gt; &#x3D; [];
    const mid_warp: number &#x3D; Math.floor(width / 2);  //for 5 this is 2
    const mid_weft: number &#x3D; Math.floor(height / 2); //for 5 this is 2
    const warps_to_wefts_ratio &#x3D; mid_warp/mid_weft;

    // first create the diamond
    for (let i &#x3D; 0; i &lt; height; i++) {
      pattern.push([]);
      const row_offset &#x3D; (i &gt; mid_weft) ? height - i : i;
      for (let j &#x3D; 0; j &lt; width; j++) {
        if (j &gt;&#x3D; mid_warp - row_offset*warps_to_wefts_ratio &amp;&amp; j &lt;&#x3D; mid_warp + row_offset*warps_to_wefts_ratio) pattern[i][j] &#x3D; new Cell(true);
        else pattern[i][j] &#x3D; new Cell(false);
      }
    }

    // carve out the tabby
    if (bindings &gt; 0) {
      const tabby_range_size &#x3D; bindings * 2 + 1;
      for (let i &#x3D; 0; i &lt; height; i++) {
        const row_offset &#x3D; (i &gt; mid_weft) ? height - i : i;
        const range_size &#x3D; Math.floor((mid_warp + row_offset*warps_to_wefts_ratio) - (mid_warp - row_offset*warps_to_wefts_ratio)) + 1;

        //figure out how many bindings we&#x27;re dealing with here - alterlate to the inside and outside of the diamong
        for (let b &#x3D; 1; b &lt;&#x3D; bindings; b++) {
          const inside &#x3D; (b % 2 &#x3D;&#x3D; 1) ? true : false;
          if (inside) {
            const increment &#x3D; Math.floor(b+1 / 2)
            const diff &#x3D; Math.ceil((range_size - tabby_range_size) / 2);
            const left_j &#x3D; mid_warp - (diff * increment);
            const right_j &#x3D; mid_warp + (diff * increment);
            if (left_j &gt; 0 &amp;&amp; left_j &lt; width) pattern[i][left_j].setHeddle(false);
            if (right_j &gt; 0 &amp;&amp; right_j &lt; width) pattern[i][right_j].setHeddle(false);
          } else {
            const increment &#x3D; Math.floor(b / 2);
            const left_j &#x3D; (mid_warp - Math.floor((range_size-1)/2)) - (increment*2);
            const right_j &#x3D; (mid_warp + Math.floor((range_size-1)/2)) + (increment*2);
            if (left_j &gt; 0 &amp;&amp; left_j &lt; width) pattern[i][left_j].setHeddle(true);
            if (right_j &gt; 0 &amp;&amp; right_j &lt; width) pattern[i][right_j].setHeddle(true);
          }
        }    
      }
    }

    let d: Draft;
    if(input &#x3D;&#x3D; undefined){
      d &#x3D; initDraftWithParams({warps: width, wefts: height, pattern: pattern});
      d.gen_name &#x3D; formatName([], &quot;waffle&quot;);
    } else {
      d &#x3D; initDraftWithParams({warps: warps(input.drawdown), wefts: wefts(input.drawdown), pattern: input.drawdown});
      d.drawdown &#x3D; applyMask(input.drawdown, pattern);         
      // format.transferSystemsAndShuttles(d, [input], params, &#x27;first&#x27;);
      d.gen_name &#x3D; formatName([input], &quot;waffle&quot;);
    }
    console.log(d);
    return d;
  }
})</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/app/core/model/canvas2image.ts</h3>
    <section>
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="CanvasToBMP"></a>
                    <span class="name">
                        <span ><b>CanvasToBMP</b></span>
                        <a href="#CanvasToBMP"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/object" target="_blank" >object</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{

  /**
   * Convert a canvas element to ArrayBuffer containing a BMP file
   * with support for 32-bit (alpha).
   *
   * Note that CORS requirement must be fulfilled.
   *
   * @param {HTMLCanvasElement} canvas - the canvas element to convert
   * @return {ArrayBuffer}
   */
  toArrayBuffer: function(canvas) {

    var w &#x3D; canvas.width,
        h &#x3D; canvas.height,
        w4 &#x3D; w * 4,
        idata &#x3D; canvas.getContext(&quot;2d&quot;).getImageData(0, 0, w, h),
        data32 &#x3D; new Uint32Array(idata.data.buffer), // 32-bit representation of canvas

        stride &#x3D; Math.floor((32 * w + 31) / 32) * 4, // row length incl. padding
        pixelArraySize &#x3D; stride * h,                 // total bitmap size
        fileLength &#x3D; 122 + pixelArraySize,           // header size is known + bitmap

        file &#x3D; new ArrayBuffer(fileLength),          // raw byte buffer (returned)
        view &#x3D; new DataView(file),                   // handle endian, reg. width etc.
        pos &#x3D; 0, x, y &#x3D; 0, p, s &#x3D; 0, a, v;

    // write file header
    setU16(0x4d42);          // BM
    setU32(fileLength);      // total length
    pos +&#x3D; 4;                // skip unused fields
    setU32(0x7a);            // offset to pixels

    // DIB header
    setU32(108);             // header size
    setU32(w);
    setU32(-h &gt;&gt;&gt; 0);        // negative &#x3D; top-to-bottom
    setU16(1);               // 1 plane
    setU16(32);              // 32-bits (RGBA)
    setU32(3);               // no compression (BI_BITFIELDS, 3)
    setU32(pixelArraySize);  // bitmap size incl. padding (stride x height)
    setU32(2835);            // pixels/meter h (~72 DPI x 39.3701 inch/m)
    setU32(2835);            // pixels/meter v
    pos +&#x3D; 8;                // skip color/important colors
    setU32(0xff0000);        // red channel mask
    setU32(0xff00);          // green channel mask
    setU32(0xff);            // blue channel mask
    setU32(0xff000000);      // alpha channel mask
    setU32(0x57696e20);      // &quot; win&quot; color space

    // bitmap data, change order of ABGR to BGRA
    while (y &lt; h) {
      p &#x3D; 0x7a + y * stride; // offset + stride x height
      x &#x3D; 0;
      while (x &lt; w4) {
        v &#x3D; data32[s++];                     // get ABGR
        a &#x3D; v &gt;&gt;&gt; 24;                        // alpha channel
        view.setUint32(p + x, (v &lt;&lt; 8) | a); // set BGRA
        x +&#x3D; 4;
      }
      y++
    }

    return file;

    // helper method to move current buffer position
    function setU16(data) {view.setUint16(pos, data, true); pos +&#x3D; 2}
    function setU32(data) {view.setUint32(pos, data, true); pos +&#x3D; 4}
  },

  /**
   * Converts a canvas to BMP file, returns a Blob representing the
   * file. This can be used with URL.createObjectURL().
   * Note that CORS requirement must be fulfilled.
   *
   * @param {HTMLCanvasElement} canvas - the canvas element to convert
   * @return {Blob}
   */
  toBlob: function(canvas) {
    return new Blob([this.toArrayBuffer(canvas)], {
      type: &quot;image/bmp&quot;
    });
  },

  /**
   * Converts the canvas to a data-URI representing a BMP file.
   * Note that CORS requirement must be fulfilled.
   *
   * @param canvas
   * @return {string}
   */
  toDataURL: function(canvas) {
    var buffer &#x3D; new Uint8Array(this.toArrayBuffer(canvas)),
        bs &#x3D; &quot;&quot;, i &#x3D; 0, l &#x3D; buffer.length;
    while (i &lt; l) bs +&#x3D; String.fromCharCode(buffer[i++]);
    return &quot;data:image/bmp;base64,&quot; + btoa(bs);
  }
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/app/core/model/looms.ts</h3>
    <section>
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="computeDrawdown"></a>
                    <span class="name">
                        <span ><b>computeDrawdown</b></span>
                        <a href="#computeDrawdown"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom: Loom) : Promise&lt;Drawdown&gt; &#x3D;&gt; {

    let pattern &#x3D; createBlankDrawdown(loom.treadling.length, loom.threading.length);
    for (var i &#x3D; 0; i &lt; loom.treadling.length;i++) {
      const active_treadles: Array&lt;number&gt; &#x3D; loom.treadling[i].slice();
      if (active_treadles.length &gt; 0) {
        active_treadles.forEach((treadle) &#x3D;&gt; {


          for (var j &#x3D; 0; j &lt; loom.tieup.length; j++) {
            if (loom.tieup[j][treadle]) {
              for (var k &#x3D; 0; k &lt; loom.threading.length;k++) {
                if (loom.threading[k] &#x3D;&#x3D; j) {
                  pattern[i][k].setHeddle(true);
                }
              }
            }
          }
        });
      }
    }

    return Promise.resolve(pattern);
  
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>computes the drawdown based on a given loom configuration</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="direct_utils"></a>
                    <span class="name">
                        <span ><b>direct_utils</b></span>
                        <a href="#direct_utils"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../classes/Util.html" target="_self" >LoomUtil</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    type: &#x27;direct&#x27;, 
    displayname: &#x27;direct-tie or dobby loom&#x27;,
    dx: &quot;draft from drawdown or threading/tieup/treadling. Assumes you are using a direct tie and mutiple treadle assignments&quot;,
    computeLoomFromDrawdown: (d: Drawdown, loom_settings: LoomSettings, origin: number) : Promise&lt;Loom&gt;  &#x3D;&gt; {
        
        const l: Loom &#x3D; {
            threading: [],
            tieup: [],
            treadling: []
        }

            //now calculate threading 
            return generateThreading(d)
            .then(obj &#x3D;&gt; {

            l.threading &#x3D; obj.threading.slice();

            //add treadling
            for(let i &#x3D; 0; i &lt; wefts(d); i++){
              let active_ts &#x3D; [];
              let i_pattern &#x3D; d[i].slice();
              i_pattern.forEach((cell, j) &#x3D;&gt; {
                if(cell.isUp()){
                  const frame_assignment &#x3D; obj.threading[j];
                  if(frame_assignment !&#x3D;&#x3D; -1){
                    active_ts.push(frame_assignment);
                  }
                }
              });
              l.treadling[i] &#x3D; utilInstance.filterToUniqueValues(active_ts);
            }

            const num_frames &#x3D; Math.max(numFrames(l), loom_settings.frames);
            const num_treadles &#x3D; Math.max(numTreadles(l), loom_settings.treadles);
            const dim &#x3D; Math.max(num_frames, num_treadles)


            l.tieup &#x3D; generateDirectTieup(dim);

             return l;

            });

    },
    computeDrawdownFromLoom: (l: Loom, origin: number) : Promise&lt;Drawdown&gt; &#x3D;&gt; {
      return computeDrawdown(l);
    },
    recomputeLoomFromThreadingAndDrawdown:(l:Loom, loom_settings: LoomSettings, d: Drawdown, origin: number): Promise&lt;Loom&gt; &#x3D;&gt;{
      const new_loom: Loom &#x3D; {
        threading: l.threading.slice(),
        tieup: [],
        treadling: []
    }

  
      //add treadling
      for(let i &#x3D; 0; i &lt; wefts(d); i++){
        let active_ts &#x3D; [];
        let i_pattern &#x3D; d[i].slice();
        i_pattern.forEach((cell, j) &#x3D;&gt; {
          if(cell.isUp()){
            const frame_assignment &#x3D; new_loom.threading[j];
            if(frame_assignment !&#x3D;&#x3D; -1){
              active_ts.push(frame_assignment);
            }
          }
        });
        new_loom.treadling[i] &#x3D; utilInstance.filterToUniqueValues(active_ts);
      }

      const num_frames &#x3D; Math.max(numFrames(l), loom_settings.frames);
      const num_treadles &#x3D; Math.max(numTreadles(l), loom_settings.treadles);
      const dim &#x3D; Math.max(num_frames, num_treadles)


      new_loom.tieup &#x3D; generateDirectTieup(dim);
      return Promise.resolve(new_loom)

    },
    updateThreading: (loom: Loom, ndx:InterlacementVal) &#x3D;&gt; {
        if(ndx.val) loom.threading[ndx.j] &#x3D; ndx.i;
        else loom.threading[ndx.j] &#x3D; -1;
        return loom;
    },
    updateTieup: (loom: Loom, ndx:InterlacementVal) &#x3D;&gt; {
      return loom;
    },
    updateTreadling : (loom: Loom, ndx:InterlacementVal) &#x3D;&gt; {
      if(ndx.val){
          if(loom.treadling[ndx.i].find(el &#x3D;&gt; el &#x3D;&#x3D;&#x3D; ndx.j) &#x3D;&#x3D;&#x3D; undefined) loom.treadling[ndx.i].push(ndx.j);
      }else{
          loom.treadling[ndx.i] &#x3D; loom.treadling[ndx.i].filter(el &#x3D;&gt; el !&#x3D;&#x3D; ndx.j);
      }
    return loom;
    },
    insertIntoThreading: (loom: Loom, j: number, val: number) : Loom &#x3D;&gt; {
      loom.threading.splice(j,0, val);
      return loom;
    },
    insertIntoTreadling: (loom: Loom, i: number, val: Array&lt;number&gt;) : Loom &#x3D;&gt; {
      loom.treadling.splice(i,0, val);
      return loom;
    },
    pasteThreading: (loom:Loom, drawdown: Drawdown, ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
     return pasteDirectAndFrameThreading(loom, drawdown, ndx, width, height);
    },
    pasteTreadling: (loom:Loom, drawdown: Drawdown, ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
      return pasteDirectAndFrameTreadling(loom, drawdown, ndx, width, height);
    },
    pasteTieup: (loom:Loom, drawdown: Drawdown,  ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
      return loom;
    },
    deleteFromThreading: (loom: Loom, j: number) : Loom &#x3D;&gt; {
      loom.threading.splice(j, 1);
      return loom;
    },
    deleteFromTreadling: (loom: Loom, i: number) : Loom &#x3D;&gt; {
      loom.treadling.splice(i, 1);
      return loom;
    }
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>contains the set of functions to be used when working on a direct tieup or dobby loom</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="flipAndComputeDrawdown"></a>
                    <span class="name">
                        <span ><b>flipAndComputeDrawdown</b></span>
                        <a href="#flipAndComputeDrawdown"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(l: Loom, horiz: boolean, vert:boolean) : Promise&lt;Drawdown&gt; &#x3D;&gt; {
    
  return flipLoom(l, horiz, vert).then(loom &#x3D;&gt; {
      return computeDrawdown(loom);
    }).then(drawdown &#x3D;&gt; {
       return drawdown
    });
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>flips the loom according to the origin and then calls functions to recalculate drawdown</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="flipLoom"></a>
                    <span class="name">
                        <span ><b>flipLoom</b></span>
                        <a href="#flipLoom"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom:Loom, horiz: boolean, vert: boolean) : Promise&lt;Loom&gt; &#x3D;&gt; {
   

    if(loom &#x3D;&#x3D;&#x3D; null || loom &#x3D;&#x3D; undefined) return Promise.resolve(null);

    const refs &#x3D; [];
    let new_loom &#x3D; {
      threading: loom.threading.slice(), 
      tieup: loom.tieup.slice(),
      treadling: loom.treadling.slice()
    }


    let fns &#x3D; [];
      if (vert){
        refs.push(&#x27;treadling&#x27;)
        fns.push(flipTreadling(loom.treadling));
      }
      if(horiz){
        refs.push(&#x27;threading&#x27;)
        fns.push(flipThreading(loom.threading))
      }

      return Promise.all(fns).then(res &#x3D;&gt; {
        for(let i &#x3D; 0; i &lt; refs.length; i++){
          if(refs[i] &#x3D;&#x3D;&#x3D; &#x27;treadling&#x27;) new_loom.treadling &#x3D; res[i];
          if(refs[i] &#x3D;&#x3D;&#x3D; &#x27;threading&#x27;) new_loom.threading &#x3D; res[i];
        }

        return Promise.resolve(new_loom);

      });
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>calls the series of functions required to flip the looms to common origin based of user selected origin.</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="flipPattern"></a>
                    <span class="name">
                        <span ><b>flipPattern</b></span>
                        <a href="#flipPattern"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(d: Drawdown, horiz: boolean, vert: boolean) : Promise&lt;Drawdown&gt; &#x3D;&gt; {


    const d_flip &#x3D; d.slice();
    // for(let i &#x3D; 0; i &lt; d.length; i++){
    //   d_flip.push([]);
    //   for(let j &#x3D; 0; j &lt; d[i].length; j++){
    //     if(horiz &amp;&amp; vert) d_flip[i][j] &#x3D; new Cell(d[d.length -1 - i][d[i].length - 1 - j].getHeddle());
    //     if(horiz &amp;&amp; !vert) d_flip[i][j] &#x3D; new Cell(d[i][(d[i].length - 1 - j)].getHeddle());
    //     if(!horiz &amp;&amp; vert) d_flip[i][j] &#x3D; new Cell(d[d.length -1 - i][j].getHeddle());
    //     if(!horiz &amp;&amp; !vert) d_flip[i][j] &#x3D; new Cell(d[i][j].getHeddle());
    //   }
    // }

    return Promise.resolve(d_flip);

  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>flips the draft horizontally and/or vertically. Used to flip the draft so that (0,0) is in the top left, no matter which origin point is selected</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="flipThreading"></a>
                    <span class="name">
                        <span ><b>flipThreading</b></span>
                        <a href="#flipThreading"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(threading: Array&lt;number&gt;) : Promise&lt;Array&lt;number&gt;&gt; &#x3D;&gt; {


    const t_flip &#x3D; [];
    for(let i &#x3D; 0; i &lt; threading.length; i++){
      t_flip[i] &#x3D; threading[threading.length -1 - i];
    }
    return Promise.resolve(t_flip);
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>flips the threading order so that what was leftmost becomes rightmost</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="flipTieUp"></a>
                    <span class="name">
                        <span ><b>flipTieUp</b></span>
                        <a href="#flipTieUp"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(tieup: Array&lt;Array&lt;boolean&gt;&gt;, horiz: boolean, vert: boolean) : Promise&lt;Array&lt;Array&lt;boolean&gt;&gt;&gt; &#x3D;&gt; {

    const t_flip:Array&lt;Array&lt;boolean&gt;&gt; &#x3D; [];
    for(let i &#x3D; 0; i &lt; tieup.length; i++){
      t_flip.push([]);
      for(let j &#x3D; 0; j &lt; tieup[i].length; j++){
        if(horiz &amp;&amp; vert) t_flip[i][j] &#x3D; tieup[tieup.length -1 - i][tieup[i].length - 1 - j];
        if(horiz &amp;&amp; !vert) t_flip[i][j] &#x3D; tieup[i][(tieup[i].length - 1 - j)];
        if(!horiz &amp;&amp; vert) t_flip[i][j] &#x3D; tieup[tieup.length -1 - i][j];
        if(!horiz &amp;&amp; !vert) t_flip[i][j] &#x3D; tieup[i][j];
      }
    }

    return Promise.resolve(t_flip);
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>flips the threading order so that what was leftmost becomes rightmost</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="flipTreadling"></a>
                    <span class="name">
                        <span ><b>flipTreadling</b></span>
                        <a href="#flipTreadling"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(treadling: Array&lt;Array&lt;number&gt;&gt;) : Promise&lt;Array&lt;Array&lt;number&gt;&gt;&gt; &#x3D;&gt;{

      const t_flip &#x3D; [];
      for(let i &#x3D; 0; i &lt; treadling.length; i++){
        t_flip[i] &#x3D; treadling[treadling.length -1 - i].slice();
      }
      return Promise.resolve(t_flip);
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>flips the threading order so that what was leftmost becomes rightmost</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="frame_utils"></a>
                    <span class="name">
                        <span ><b>frame_utils</b></span>
                        <a href="#frame_utils"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../classes/Util.html" target="_self" >LoomUtil</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    type: &#x27;frame&#x27;, 
    displayname: &#x27;shaft/treadle loom&#x27;,
    dx: &quot;draft from drawdown or threading/tieup/treadling. Assumes you are assigning treadles to specific frame via tieup&quot;,
    computeLoomFromDrawdown: (d: Drawdown, loom_settings: LoomSettings, origin: number) : Promise&lt;Loom&gt;  &#x3D;&gt; {
        const loom: Loom &#x3D; {
            threading: [],
            tieup: [],
            treadling: []
        }
         
        return generateThreading(d)
          .then(threading &#x3D;&gt; {
            loom.threading &#x3D; threading.threading;
            return generateTreadlingforFrameLoom(d)
          })
          .then(treadling &#x3D;&gt; {
            loom.treadling &#x3D; treadling.treadling;
        
            loom.tieup &#x3D; [];
            const num_frames &#x3D; Math.max(numFrames(loom), loom_settings.frames);
            const num_treadles &#x3D; Math.max(numTreadles(loom), loom_settings.treadles);

            for(let frames &#x3D; 0; frames &lt; num_frames; frames++){
              loom.tieup.push([]);
              for(let treadles &#x3D; 0; treadles &lt; num_treadles; treadles++){
                loom.tieup[frames].push(false);
              }
            }

            for(let i &#x3D; 0; i &lt; loom.treadling.length; i++){
              if(loom.treadling[i].length &gt; 0){
                const active_treadle_id &#x3D; loom.treadling[i][0];
                const row &#x3D; d[i];
                row.forEach((cell, j) &#x3D;&gt; {
                  if(cell.isUp()){
                    const active_frame_id &#x3D; loom.threading[j];
                    loom.tieup[active_frame_id][active_treadle_id] &#x3D; true;
                  } 
                });
              }
            }

            return loom;
          })

      
    
    },
    
    computeDrawdownFromLoom: (l: Loom, origin: number) : Promise&lt;Drawdown&gt; &#x3D;&gt; {
      return computeDrawdown(l);
    },
    recomputeLoomFromThreadingAndDrawdown:(l:Loom, loom_settings: LoomSettings, d: Drawdown, origin: number): Promise&lt;Loom&gt; &#x3D;&gt;{
      const new_loom: Loom &#x3D; {
        threading: l.threading.slice(),
        tieup: [],
        treadling: []
      }
     
      return  generateTreadlingforFrameLoom(d)
      .then(treadling &#x3D;&gt; {
        new_loom.treadling &#x3D; treadling.treadling;
    
        new_loom.tieup &#x3D; [];
        const num_frames &#x3D; Math.max(numFrames(l), loom_settings.frames);
        const num_treadles &#x3D; Math.max(numTreadles(l), loom_settings.treadles);

        for(let frames &#x3D; 0; frames &lt; num_frames; frames++){
          new_loom.tieup.push([]);
          for(let treadles &#x3D; 0; treadles &lt; num_treadles; treadles++){
            new_loom.tieup[frames].push(false);
          }
        }

        for(let i &#x3D; 0; i &lt; new_loom.treadling.length; i++){
          if(new_loom.treadling[i].length &gt; 0){
            const active_treadle_id &#x3D; new_loom.treadling[i][0];
            const row &#x3D; d[i];
            row.forEach((cell, j) &#x3D;&gt; {
              if(cell.isUp()){
                const active_frame_id &#x3D; new_loom.threading[j];
                new_loom.tieup[active_frame_id][active_treadle_id] &#x3D; true;
              } 
            });
          }
        }

        return Promise.resolve(new_loom);
      })
    },
    updateThreading: (loom:Loom, ndx: InterlacementVal) : Loom &#x3D;&gt; {
        if(ndx.val) loom.threading[ndx.j] &#x3D; ndx.i;
        else loom.threading[ndx.j] &#x3D; -1;
        return loom;
    },
    updateTieup: (loom:Loom, ndx: InterlacementVal) : Loom &#x3D;&gt; {
        loom.tieup[ndx.i][ndx.j] &#x3D; ndx.val;
        return loom;

    },
    updateTreadling: (loom:Loom, ndx: InterlacementVal) : Loom &#x3D;&gt; {
        if(ndx.val){
            if(loom.treadling[ndx.i].length &gt; 0) loom.treadling[ndx.i] &#x3D; [];
            loom.treadling[ndx.i].push(ndx.j);
        }else{
            loom.treadling[ndx.i] &#x3D; loom.treadling[ndx.i].filter(el &#x3D;&gt; el !&#x3D;&#x3D; ndx.j);
        }
      return loom;
    },
    insertIntoThreading: (loom: Loom, j: number, val: number) : Loom &#x3D;&gt; {
      loom.threading.splice(j,0, val);
      return loom;
    },
    insertIntoTreadling: (loom: Loom, i: number, val: Array&lt;number&gt;) : Loom &#x3D;&gt; {
      loom.treadling.splice(i,0, val);
      return loom;
    },
    pasteThreading: (loom:Loom, drawdown: Drawdown, ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
      return pasteDirectAndFrameThreading(loom, drawdown, ndx, width, height);
    },
    pasteTreadling: (loom:Loom,drawdown: Drawdown, ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
      return pasteDirectAndFrameTreadling(loom, drawdown, ndx, width, height);
    },
    pasteTieup: (loom:Loom,drawdown: Drawdown, ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
      return loom;
    },
    deleteFromThreading: (loom: Loom, j: number) : Loom &#x3D;&gt; {
      loom.threading.splice(j, 1);
      return loom;
    },
    deleteFromTreadling: (loom: Loom, i: number) : Loom &#x3D;&gt; {
      loom.treadling.splice(i, 1);
      return loom;
    }

  
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>contains the set of functions to be used when working on a frame loom</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="generateDirectTieup"></a>
                    <span class="name">
                        <span ><b>generateDirectTieup</b></span>
                        <a href="#generateDirectTieup"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(size:number) : Array&lt;Array&lt;boolean&gt;&gt; &#x3D;&gt; {
 //add tieup
    const tieup &#x3D; [];
    for(let i &#x3D; 0; i &lt; size; i++){
      tieup.push([]);
      for(let j &#x3D; 0; j &lt; size; j++){
        if(i &#x3D;&#x3D; j) tieup[i][j] &#x3D; true;
        else tieup[i][j] &#x3D; false;
      }
    }
    return tieup.slice();
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>generates a direct tieup for the give size</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="generateThreading"></a>
                    <span class="name">
                        <span ><b>generateThreading</b></span>
                        <a href="#generateThreading"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(drawdown: Drawdown) : Promise&lt;{threading: Array&lt;number&gt;, num: number}&gt; &#x3D;&gt; {
    let frame &#x3D; -1;
    let threading &#x3D; [];
    //always assign the origin to one
    //threading[] &#x3D; -1;

    //progressively add new frames in the order they appear
    for(let j &#x3D; 0; j &lt; warps(drawdown); j++){
      const blank &#x3D; utilInstance.colIsBlank(j, drawdown);
      if(blank) threading[j] &#x3D; -1;
      else{
      const match &#x3D; utilInstance.hasMatchingColumn(j, drawdown);
        if(match &#x3D;&#x3D;&#x3D; -1 || match &gt; j){
          frame++;
          threading[j] &#x3D; frame;
        }else{
          threading[j] &#x3D; threading[match];
        }
      }
    }

    return Promise.resolve({threading:threading, num:frame});

  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>generates a threading based on the provided drawdown</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="generateTreadlingforFrameLoom"></a>
                    <span class="name">
                        <span ><b>generateTreadlingforFrameLoom</b></span>
                        <a href="#generateTreadlingforFrameLoom"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(pattern: Drawdown) : Promise&lt;{treadling:Array&lt;Array&lt;number&gt;&gt;, num:number}&gt; &#x3D;&gt;{
    let treadle &#x3D; -1;
    let treadling &#x3D; [];
    //always assign the origin to one

    //progressively add new frames in the order they appear
    for(let i &#x3D; 0; i &lt; pattern.length; i++){

      const has_up &#x3D; pattern[i].find(el &#x3D;&gt; el.isUp());
      if(has_up &#x3D;&#x3D;&#x3D; undefined) treadling[i] &#x3D; [];
      else{
      const match &#x3D; utilInstance.hasMatchingRow(i, pattern);
        if(match &#x3D;&#x3D;&#x3D; -1 || match &gt; i){
          treadle++;
          treadling[i] &#x3D; [treadle];
        }else{
          treadling[i] &#x3D; treadling[match];
        }
      }
    }
    return Promise.resolve({treadling: treadling, num: treadle});

  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>This function sets the treadling based on a adjusted pattern (e.g. a pattern that has been flipped based on the users selected origin point)</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="getLoomUtilByType"></a>
                    <span class="name">
                        <span ><b>getLoomUtilByType</b></span>
                        <a href="#getLoomUtilByType"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(type: &#x27;frame&#x27; | &#x27;direct&#x27; | &#x27;jacquard&#x27; | string) : LoomUtil &#x3D;&gt;{

    switch(type){
        case &#x27;frame&#x27;: return frame_utils;
        case &#x27;direct&#x27;: return direct_utils;
        case &#x27;jacquard&#x27;: return jacquard_utils;
    }

}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>returns the correct loom util object by string</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isFrame"></a>
                    <span class="name">
                        <span ><b>isFrame</b></span>
                        <a href="#isFrame"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom_settings: LoomSettings) : boolean &#x3D;&gt; {
  if(loom_settings.type !&#x3D;&#x3D; &#x27;jacquard&#x27;) return true;
  return false;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>returns true if this loom typically requires a view of threading and tieup</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isInThreadingRange"></a>
                    <span class="name">
                        <span ><b>isInThreadingRange</b></span>
                        <a href="#isInThreadingRange"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom: Loom, ndx: Interlacement) : boolean &#x3D;&gt; {
  if(ndx.i &lt; 0) return false;
  if(ndx.i &gt; numFrames(loom)) return false;
  if(ndx.j &lt; 0) return false;
  if(ndx.j &gt;&#x3D; loom.threading.length) return false;
  return true;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>checks if a given interlacement is within the range of the threading</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isInTieupRange"></a>
                    <span class="name">
                        <span ><b>isInTieupRange</b></span>
                        <a href="#isInTieupRange"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom: Loom, ndx: Interlacement) : boolean &#x3D;&gt; {
  if(ndx.i &lt; 0) return false;
  if(ndx.i &gt; loom.tieup.length) return false;
  if(ndx.i &lt; 0) return false;
  if(ndx.i &gt;&#x3D; loom.tieup[0].length) return false;
  return true;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>checks if a given interlacement is within the range of the threading</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isInTreadlingRange"></a>
                    <span class="name">
                        <span ><b>isInTreadlingRange</b></span>
                        <a href="#isInTreadlingRange"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom: Loom, ndx: Interlacement) : boolean &#x3D;&gt; {
  if(ndx.j &lt; 0) return false;
  if(ndx.j &gt; numTreadles(loom)) return false;
  if(ndx.i &lt; 0) return false;
  if(ndx.i &gt;&#x3D; loom.treadling.length) return false;
  return true;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>checks if a given interlacement is within the range of the threading</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isInUserThreadingRange"></a>
                    <span class="name">
                        <span ><b>isInUserThreadingRange</b></span>
                        <a href="#isInUserThreadingRange"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom: Loom, loom_settings: LoomSettings, ndx: Interlacement) : boolean &#x3D;&gt; {
  
  const frames &#x3D; Math.max(loom_settings.frames, numFrames(loom));
  
  if(ndx.i &lt; 0) return false;
  if(ndx.i &gt; frames) return false;
  if(ndx.j &lt; 0) return false;
  if(ndx.j &gt;&#x3D; loom.threading.length) return false;
  return true;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>checks if a given interlacement is within the range of the threading specified by the user</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isInUserTieupRange"></a>
                    <span class="name">
                        <span ><b>isInUserTieupRange</b></span>
                        <a href="#isInUserTieupRange"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom: Loom, loom_settings: LoomSettings, ndx: Interlacement) : boolean &#x3D;&gt; {
  const frames &#x3D; Math.max(loom_settings.frames, numFrames(loom));
  const treadling &#x3D; Math.max(loom_settings.treadles, numTreadles(loom));

  if(ndx.i &lt; 0) return false;
  if(ndx.i &gt;&#x3D; frames) return false;
  if(ndx.i &lt; 0) return false;
  if(ndx.i &gt;&#x3D; treadling) return false;
  return true;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>checks if a given interlacement is within the range of the threading including the user defined settings</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isInUserTreadlingRange"></a>
                    <span class="name">
                        <span ><b>isInUserTreadlingRange</b></span>
                        <a href="#isInUserTreadlingRange"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom: Loom, loom_settings: LoomSettings, ndx: Interlacement) : boolean &#x3D;&gt; {
  
  const treadling &#x3D; Math.max(loom_settings.treadles, numTreadles(loom));

  if(ndx.j &lt; 0) return false;
  if(ndx.j &gt; treadling) return false;
  if(ndx.i &lt; 0) return false;
  if(ndx.i &gt;&#x3D; loom.treadling.length) return false;
  return true;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>checks if a given interlacement is within the range of the threading</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="jacquard_utils"></a>
                    <span class="name">
                        <span ><b>jacquard_utils</b></span>
                        <a href="#jacquard_utils"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../classes/Util.html" target="_self" >LoomUtil</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    type: &#x27;jacquard&#x27;, 
    displayname: &#x27;jacquard loom&#x27;,
    dx: &quot;draft exclusively from drawdown, disregarding any frame and treadle information&quot;,
    computeLoomFromDrawdown: (d: Drawdown, loom_settings: LoomSettings, origin: number) : Promise&lt;Loom&gt;  &#x3D;&gt; {
     return Promise.resolve(null);
    },
    computeDrawdownFromLoom: (l: Loom) : Promise&lt;Drawdown&gt; &#x3D;&gt; {
      return Promise.resolve(null);
    },
    recomputeLoomFromThreadingAndDrawdown:(l:Loom, loom_settings: LoomSettings, d: Drawdown, origin: number): Promise&lt;Loom&gt; &#x3D;&gt;{
      return Promise.resolve(null);
    },
    updateThreading: (loom: Loom, ndx:InterlacementVal) &#x3D;&gt; {
      return loom;
    },
    updateTieup: (loom: Loom,ndx:InterlacementVal) &#x3D;&gt; {
      return loom;
    },
    updateTreadling : (loom: Loom,ndx:InterlacementVal) &#x3D;&gt; {
      return loom;
    },
    insertIntoThreading: (loom: Loom, j: number, val: number) : Loom &#x3D;&gt; {
      return loom;
    },
    insertIntoTreadling: (loom: Loom, i: number, val: Array&lt;number&gt;) : Loom &#x3D;&gt; {
      return loom;
    },
    pasteThreading: (loom:Loom, drawdown: Drawdown,ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
      return loom;
    },
    pasteTreadling: (loom:Loom, drawdown: Drawdown,ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
      return loom;
    },
    pasteTieup: (loom:Loom, drawdown: Drawdown,ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
      return loom;
    },
    deleteFromThreading: (loom: Loom, j: number) : Loom &#x3D;&gt; {
      return loom;
    },
    deleteFromTreadling: (loom: Loom, i: number) : Loom &#x3D;&gt; {
      return loom;
    }

  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>********* ESTABLISH SPECIFIC TYPES OF LOOMS and A CORE SET OF FUNCTIONS FOR EACH ***********</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="loadLoomFromFile"></a>
                    <span class="name">
                        <span ><b>loadLoomFromFile</b></span>
                        <a href="#loadLoomFromFile"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom: any, flips: any, version: string) : Promise&lt;Loom&gt; &#x3D;&gt; {

  if(loom &#x3D;&#x3D; null) return Promise.resolve(null);

  if (!utilInstance.sameOrNewerVersion(version, &#x27;3.4.5&#x27;)) {
    //tranfer the old treadling style on looms to the new style updated in 3.4.5
    loom.treadling &#x3D; loom.treadling.map(treadle_id &#x3D;&gt; {
      if(treadle_id &#x3D;&#x3D; -1) return [];
      else return [treadle_id];
    });
  
  } else {
    // handle case where firebase does not save empty treadles
    // console.log(&quot;IN LOAD LOOM&quot;, loom.treadling);
    for(let i &#x3D; 0; i &lt; loom.treadling.length; i++){
      if (loom.treadling[i].length &#x3D;&#x3D; 1 &amp;&amp; loom.treadling[i][0] &#x3D;&#x3D; -1) loom.treadling[i] &#x3D; [];
    }
  }
  
  return flipLoom(loom, flips.horiz, flips.vert)
  .then(flipped &#x3D;&gt; {
    return flipped;
  })
    
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>sets up the draft from the information saved in a .ada file</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="numFrames"></a>
                    <span class="name">
                        <span ><b>numFrames</b></span>
                        <a href="#numFrames"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom: Loom) : number &#x3D;&gt; {

  if(loom &#x3D;&#x3D;&#x3D; null || loom &#x3D;&#x3D;&#x3D; undefined) return 0;

  let max &#x3D; loom.threading.reduce((acc, el) &#x3D;&gt; {
    if(el &gt; acc){
      acc &#x3D; el;
    }
    return acc;
  }, 0);
  return max+1;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>calculates the total number of frames used in this loom
since its called frequently, keep an eye on this to make sure it isn&#39;t hanging page loading 
and/or call it once per needed function (instead of multiple times in one function)</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="numTreadles"></a>
                    <span class="name">
                        <span ><b>numTreadles</b></span>
                        <a href="#numTreadles"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom: Loom) : number &#x3D;&gt; {

  if(loom &#x3D;&#x3D; null) return 0;

  let max &#x3D;  loom.treadling.reduce((acc, el) &#x3D;&gt; {
    
    let max_in_list &#x3D; el.reduce((sub_acc, sub_el) &#x3D;&gt; {
      if(sub_el &gt; acc) sub_acc &#x3D; sub_el;
      return sub_acc;
    }, 0) ;
    
    if(max_in_list &gt; acc){
      acc &#x3D; max_in_list;
    }
    return acc;
  }, 0);

  return max+1;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>calculates the total number of frames used in this loom
since its called frequently, keep an eye on this to make sure it isn&#39;t hanging page loading</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="pasteDirectAndFrameThreading"></a>
                    <span class="name">
                        <span ><b>pasteDirectAndFrameThreading</b></span>
                        <a href="#pasteDirectAndFrameThreading"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom:Loom, drawdown: Drawdown, ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
    
  for(let j &#x3D; 0; j &lt; width; j++){
    const pattern_ndx &#x3D; j % drawdown[0].length;
    const column_vals &#x3D; drawdown.map(row &#x3D;&gt; row[pattern_ndx]);
    const frame &#x3D; column_vals.findIndex(cell &#x3D;&gt; cell.getHeddle() &#x3D;&#x3D; true);
    if(frame &lt; numFrames(loom)) loom.threading[ndx.j + j] &#x3D; frame;
  }

  return loom;

}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><ul>
<li>SHARED FUNCTIONS USED WHEN COMPUTING LOOM STATESs *******</li>
</ul>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="pasteDirectAndFrameTreadling"></a>
                    <span class="name">
                        <span ><b>pasteDirectAndFrameTreadling</b></span>
                        <a href="#pasteDirectAndFrameTreadling"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(loom:Loom, drawdown: Drawdown, ndx: InterlacementVal, width: number, height: number) : Loom &#x3D;&gt; {
    
  for(let i &#x3D; 0; i &lt; height; i++){
    const pattern_ndx &#x3D; i % drawdown.length;
    const treadle_list &#x3D; [];
    for(let j &#x3D; 0; j &lt; numTreadles(loom); j++){
      if(drawdown[pattern_ndx][j].getHeddle() &#x3D;&#x3D; true) treadle_list.push(j);
    }
    loom.treadling[ndx.i + i] &#x3D; treadle_list.slice();
  }

  return loom;

}</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/app/core/model/yarnsimulation.ts</h3>
    <section>
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="computeYarnPaths"></a>
                    <span class="name">
                        <span ><b>computeYarnPaths</b></span>
                        <a href="#computeYarnPaths"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(draft: Draft, shuttles: Array&lt;Shuttle&gt;) : YarnSim &#x3D;&gt; {
    

    const pattern &#x3D; draft.drawdown.slice();
    const yarnsim:YarnSim &#x3D; [];

    // //unset_all
    for(let i &#x3D; 0; i &lt; pattern.length; i++){
        yarnsim.push([]);
        for(let j &#x3D; 0; j &lt; pattern[i].length; j++){
            yarnsim[i].push(0b0000);
        }
      }
  
  
      for (var l &#x3D; 0; l &lt; shuttles.length; l++) {
  
        // Draw each shuttle on by one.
        var shuttle &#x3D; shuttles[l];
  
        //acc is an array of row_ids that are assigned to this shuttle
        const acc &#x3D; draft.rowShuttleMapping.reduce((acc, v, idx) &#x3D;&gt; v &#x3D;&#x3D;&#x3D; shuttle.id ? acc.concat([idx]) : acc, []);
  
        //screen rows are reversed to go from bottom to top
        //[row index] -&gt; (indexes where there is interlacement)
        let path:Array&lt;{row:number, overs: Array&lt;number&gt;}&gt; &#x3D; [];
        for (var i &#x3D; 0; i &lt; acc.length ; i++) {
         
          //this gets the row
          const row_values &#x3D; pattern[acc[i]];
  
  
          const overs &#x3D; row_values.reduce((overs, v, idx) &#x3D;&gt; v.isUp() ? overs.concat([idx]) : overs, []);
  
          //only push the rows with at least one interlacement     
          if(overs.length &gt; 0 &amp;&amp; overs.length &lt; row_values.length){
            path.push({row: acc[i], overs:overs});
          }
        
        }
  
        var started &#x3D; false;
        var last &#x3D; {
          row: 0,
          ndx: 0
        };
  
        path &#x3D; path.reverse();
  
  
        for(let k &#x3D; 0; k &lt; path.length; k++){
  
          let row:number &#x3D; path[k].row; 
          let overs:Array&lt;number&gt; &#x3D; path[k].overs; 
  
          let next_path &#x3D; getNextPath(path, k);
  
          let min_ndx:number &#x3D; overs.shift();
          let max_ndx:number &#x3D; overs.pop();
          
          let next_min_ndx:number;
          let next_max_ndx:number;
          
          if(next_path.row !&#x3D;&#x3D; -1 ){
           
            next_max_ndx &#x3D; next_path.overs[next_path.overs.length-1];
            next_min_ndx &#x3D; next_path.overs[0];
  
          }else{
            next_min_ndx &#x3D; min_ndx;
            next_max_ndx &#x3D; max_ndx;
          }  
  
  
  
          let moving_left:boolean &#x3D; (k%2 &#x3D;&#x3D;&#x3D; 0 &amp;&amp; shuttle.insert) || (k%2 !&#x3D;&#x3D; 0 &amp;&amp; !shuttle.insert);
  
          if(moving_left){
            if(started) max_ndx &#x3D; Math.max(max_ndx, last.ndx);
            min_ndx &#x3D; Math.min(min_ndx, next_min_ndx);
          } else {
            max_ndx &#x3D; Math.max(max_ndx, next_max_ndx);
            if(started) min_ndx &#x3D; Math.min(min_ndx, last.ndx);
  
          }
         
          //draw upwards if required
          if(started){
  
            
           // console.log(&quot;row/last.row&quot;, row, last.row);
            // for(let j &#x3D; last.row-1; j &gt; row; j--){
            //  if(moving_left) this.setNorthSouth(j, last.ndx+1);
            //  else this.setNorthSouth(j, last.ndx-1);
            // }
          }
  
          //set by lookiing at the ends ends
          if(moving_left){
  
            if(started){
                yarnsim[row][max_ndx+1] &#x3D; setSouth(yarnsim[row][max_ndx+1]); //set where it came from
            } 
            
            yarnsim[row][max_ndx+1] &#x3D; setWest(yarnsim[row][max_ndx+1]);
            yarnsim[row][max_ndx-1] &#x3D; setNorth(yarnsim[row][max_ndx-1]);
            yarnsim[row][max_ndx-1] &#x3D; setEast(yarnsim[row][max_ndx-1]);
  
            last.ndx &#x3D; min_ndx;
  
          }else{
  
            if(started){
                yarnsim[row][max_ndx-1] &#x3D; setSouth(yarnsim[row][max_ndx-1]);
            }
  
            yarnsim[row][max_ndx-1] &#x3D; setEast(yarnsim[row][max_ndx-1]);
            yarnsim[row][max_ndx+1] &#x3D; setNorth(yarnsim[row][max_ndx+1]);
            yarnsim[row][max_ndx+1] &#x3D; setWest(yarnsim[row][max_ndx+1]);
            
            last.ndx &#x3D; max_ndx;
  
          } 
  
          //set in between
          for(i &#x3D; min_ndx; i &lt;&#x3D; max_ndx; i++){
             yarnsim[row][i] &#x3D; setEastWest(yarnsim[row][i]); 
          }
  
          started &#x3D; true;
          last.row &#x3D; row;
         
        } 
      }

      return yarnsim.slice();


    }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="getDirection"></a>
                    <span class="name">
                        <span ><b>getDirection</b></span>
                        <a href="#getDirection"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(neighbors:number, is_up:boolean) : string &#x3D;&gt;{

  var is_up_dirs &#x3D;     [&quot;ew&quot;,&quot;ew&quot;, &quot;ns&quot;, &quot;sw&quot;, &quot;ew&quot;, &quot;ew&quot;, &quot;se&quot;, &quot;ew&quot;, &quot;ns&quot;, &quot;nw&quot;, &quot;ns&quot;, &quot;ew&quot;, &quot;ne&quot;, &quot;ew&quot;, &quot;ew&quot;, &quot;ew&quot;];
  var not_is_up_dirs &#x3D; [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;,  &quot;sw&quot;, &quot;x&quot;,  &quot;ew&quot;, &quot;se&quot;, &quot;ew&quot;, &quot;x&quot;,  &quot;nw&quot;, &quot;ns&quot;, &quot;sw&quot;, &quot;ne&quot;, &quot;ew&quot;, &quot;sw&quot;, &quot;ew&quot;];
  
  if(is_up) return is_up_dirs[neighbors];
  else return not_is_up_dirs[neighbors];

}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="getNextPath"></a>
                    <span class="name">
                        <span ><b>getNextPath</b></span>
                        <a href="#getNextPath"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(paths:Array&lt;{row:number, overs: Array&lt;number&gt;}&gt;, i:number) : {row:number, overs: Array&lt;number&gt;} &#x3D;&gt;{
  if(i+1 &lt; paths.length){
    return paths[i+1];
  }

  return {
    row: -1,
    overs: []
  }

}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="hasEast"></a>
                    <span class="name">
                        <span ><b>hasEast</b></span>
                        <a href="#hasEast"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell):boolean &#x3D;&gt;{
    let p:number &#x3D; cell &gt;&gt;&gt; 2;
    return((p %2)&#x3D;&#x3D;&#x3D;1);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="hasEastNeighbor"></a>
                    <span class="name">
                        <span ><b>hasEastNeighbor</b></span>
                        <a href="#hasEastNeighbor"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(drawdown: Drawdown, i:number, j:number): boolean &#x3D;&gt;{
    
    for(var ndx &#x3D; j+1; ndx &lt; warps(drawdown); ndx++){
      if(drawdown[i][ndx].isUp()) return true;
    }
    return false;
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="hasNorth"></a>
                    <span class="name">
                        <span ><b>hasNorth</b></span>
                        <a href="#hasNorth"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell: YarnCell):boolean &#x3D;&gt;{
    let p:number &#x3D; cell &gt;&gt;&gt; 3;
    return(p &#x3D;&#x3D;&#x3D; 1);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="hasNorthNeighbor"></a>
                    <span class="name">
                        <span ><b>hasNorthNeighbor</b></span>
                        <a href="#hasNorthNeighbor"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(draft: Draft, i:number, j:number, shuttle_id: number): boolean &#x3D;&gt;{
      for(var ndx &#x3D; i-1; ndx &gt;&#x3D; 0; ndx--){
        if(draft.rowShuttleMapping[ndx] &#x3D;&#x3D;&#x3D; shuttle_id){
          if(draft.drawdown[ndx][j].isUp()) return true;
          if(hasWestNeighbor(draft.drawdown, ndx,j)) return true;
          if(hasEastNeighbor(draft.drawdown, ndx,j)) return true;
        }
      }
      return false;
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="hasSouth"></a>
                    <span class="name">
                        <span ><b>hasSouth</b></span>
                        <a href="#hasSouth"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell):boolean &#x3D;&gt;{
    let p:number &#x3D; cell &gt;&gt;&gt; 1;
    return((p %2)&#x3D;&#x3D;&#x3D;1);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="hasSouthNeighbor"></a>
                    <span class="name">
                        <span ><b>hasSouthNeighbor</b></span>
                        <a href="#hasSouthNeighbor"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(draft: Draft, i:number, j:number, shuttle_id:number): boolean &#x3D;&gt;{
      for(var ndx &#x3D; i+1; ndx &lt; wefts(draft.drawdown); ndx++){
        if(draft.rowShuttleMapping[ndx] &#x3D;&#x3D;&#x3D; shuttle_id){
          if(draft.drawdown[ndx][j].isUp()) return true;
          if(hasWestNeighbor(draft.drawdown, ndx,j)) return true;
          if(hasEastNeighbor(draft.drawdown, ndx,j)) return true;
        }
      }
      return false;
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="hasWest"></a>
                    <span class="name">
                        <span ><b>hasWest</b></span>
                        <a href="#hasWest"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell):boolean &#x3D;&gt;{
    return((cell %2)&#x3D;&#x3D;&#x3D;1);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="hasWestNeighbor"></a>
                    <span class="name">
                        <span ><b>hasWestNeighbor</b></span>
                        <a href="#hasWestNeighbor"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(drawdown: Drawdown, i:number, j:number): boolean &#x3D;&gt;{

    for(var ndx &#x3D; j-1; ndx &gt;&#x3D; 0; ndx--){
      if(drawdown[i][ndx].isUp()) return true;
    }
    return false;
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isEast"></a>
                    <span class="name">
                        <span ><b>isEast</b></span>
                        <a href="#isEast"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell):boolean &#x3D;&gt;{
    return ((cell &amp; 0b0100) &#x3D;&#x3D;&#x3D; 0b0100);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isEastWest"></a>
                    <span class="name">
                        <span ><b>isEastWest</b></span>
                        <a href="#isEastWest"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell: YarnCell): boolean &#x3D;&gt; {
    return ((cell &amp; 0b0101) &#x3D;&#x3D;&#x3D; 0b0101);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isNorthEast"></a>
                    <span class="name">
                        <span ><b>isNorthEast</b></span>
                        <a href="#isNorthEast"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell):boolean &#x3D;&gt;{
    return ((cell &amp; 0b1100) &#x3D;&#x3D;&#x3D; 0b1100);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isNorthSouth"></a>
                    <span class="name">
                        <span ><b>isNorthSouth</b></span>
                        <a href="#isNorthSouth"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell):boolean &#x3D;&gt;{
    return ((cell &amp; 0b1010) &#x3D;&#x3D;&#x3D; 0b1010);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isNorthWest"></a>
                    <span class="name">
                        <span ><b>isNorthWest</b></span>
                        <a href="#isNorthWest"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell):boolean &#x3D;&gt;{
    return ((cell &amp; 0b1001) &#x3D;&#x3D;&#x3D; 0b1001);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isSouthEast"></a>
                    <span class="name">
                        <span ><b>isSouthEast</b></span>
                        <a href="#isSouthEast"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell: YarnCell) :boolean &#x3D;&gt;{
    return ((cell &amp; 0b0110) &#x3D;&#x3D;&#x3D; 0b0110);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isSouthWest"></a>
                    <span class="name">
                        <span ><b>isSouthWest</b></span>
                        <a href="#isSouthWest"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell: YarnCell):boolean &#x3D;&gt;{
    return ((cell &amp; 0b0011) &#x3D;&#x3D;&#x3D; 0b0011);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="isWest"></a>
                    <span class="name">
                        <span ><b>isWest</b></span>
                        <a href="#isWest"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell: YarnCell):boolean &#x3D;&gt;{
    return ((cell &amp; 0b0001) &#x3D;&#x3D;&#x3D; 0b0001);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="pingNeighbors"></a>
                    <span class="name">
                        <span ><b>pingNeighbors</b></span>
                        <a href="#pingNeighbors"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(draft: Draft, i:number, j:number): number &#x3D;&gt;{

    let cell:YarnCell &#x3D; 0b0000;
    let shuttle_id: number &#x3D; draft.rowShuttleMapping[i];


    if(hasNorthNeighbor(draft, i,j,shuttle_id)) cell &#x3D; setNorth(cell); 
    if(hasEastNeighbor(draft.drawdown, i,j)) cell &#x3D; setEast(cell);             
    if(hasSouthNeighbor(draft, i,j,shuttle_id)) cell &#x3D; setSouth(cell); 
    if(hasWestNeighbor(draft.drawdown, i,j)) cell &#x3D; setWest(cell);            

    return cell;
  }</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><ul>
<li>determines the directionality of the yarn at this particular point in the cell
it considers each draft cell having four poles (NESW) and determines which of those are active</li>
</ul>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setEast"></a>
                    <span class="name">
                        <span ><b>setEast</b></span>
                        <a href="#setEast"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell: YarnCell) : YarnCell &#x3D;&gt; {
    return (cell | 0b0100);

  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setEastNeighbors"></a>
                    <span class="name">
                        <span ><b>setEastNeighbors</b></span>
                        <a href="#setEastNeighbors"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(drawdown: Drawdown, yarnsim: YarnSim, i:number, j:number) : YarnSim &#x3D;&gt;{

    for(var ndx &#x3D; j+1; ndx &lt; warps(drawdown); ndx++){
      yarnsim[i][ndx] &#x3D; setWest( yarnsim[i][ndx]);
      if(drawdown[i][ndx].isUp()) return;
    }

    return yarnsim;
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setEastWest"></a>
                    <span class="name">
                        <span ><b>setEastWest</b></span>
                        <a href="#setEastWest"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell) : YarnCell &#x3D;&gt;{
    cell &#x3D; setEast(cell);
    cell &#x3D; setWest(cell);
    return cell;
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setNorth"></a>
                    <span class="name">
                        <span ><b>setNorth</b></span>
                        <a href="#setNorth"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell: YarnCell) : YarnCell &#x3D;&gt;{
    return (cell | 0b1000);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setNorthNeighbors"></a>
                    <span class="name">
                        <span ><b>setNorthNeighbors</b></span>
                        <a href="#setNorthNeighbors"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(draft: Draft, i:number, j:number, shuttle_id: number): boolean &#x3D;&gt;{

      for(var ndx &#x3D; i-1; ndx &gt;&#x3D; 0; ndx--){
        if(draft.rowShuttleMapping[ndx] &#x3D;&#x3D;&#x3D; shuttle_id){
          
             

          for(var col &#x3D; 0; col &lt; warps(draft.drawdown); col++){
            
          }

          if(draft.drawdown[ndx][j].isUp()) return true;
          if(hasWestNeighbor(draft.drawdown, ndx,j)) return true;
          if(hasEastNeighbor(draft.drawdown, ndx,j)) return true;
        }
      }
      return false;
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setNorthSouth"></a>
                    <span class="name">
                        <span ><b>setNorthSouth</b></span>
                        <a href="#setNorthSouth"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell) : YarnCell &#x3D;&gt; {
    cell &#x3D; setNorth(cell);
    cell &#x3D; setSouth(cell);
    return cell;
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setPoles"></a>
                    <span class="name">
                        <span ><b>setPoles</b></span>
                        <a href="#setPoles"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell, poles: number) : YarnCell &#x3D;&gt;{
     cell &#x3D; poles;
     return cell;
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setSouth"></a>
                    <span class="name">
                        <span ><b>setSouth</b></span>
                        <a href="#setSouth"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell) : YarnCell &#x3D;&gt;{
    return (cell | 0b0010);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setWest"></a>
                    <span class="name">
                        <span ><b>setWest</b></span>
                        <a href="#setWest"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell) : YarnCell &#x3D;&gt;{
   return (cell | 0b0001);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setWestNeighbors"></a>
                    <span class="name">
                        <span ><b>setWestNeighbors</b></span>
                        <a href="#setWestNeighbors"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(yarnsim: YarnSim, drawdown: Drawdown, i:number, j:number) : YarnSim &#x3D;&gt; {

    for(var ndx &#x3D; j-1; ndx &gt;&#x3D; 0; ndx--){
      yarnsim[i][ndx] &#x3D; setEast(yarnsim[i][ndx]);
      if(drawdown[i][ndx].isUp()) return;
    }

    return yarnsim;
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><ul>
<li>If this doesn&#39;t have east set, then there is nothing to the west</li>
</ul>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="unsetEast"></a>
                    <span class="name">
                        <span ><b>unsetEast</b></span>
                        <a href="#unsetEast"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell) : YarnCell &#x3D;&gt;{
   return (cell ^ 0b010);

  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="unsetEastNeighbors"></a>
                    <span class="name">
                        <span ><b>unsetEastNeighbors</b></span>
                        <a href="#unsetEastNeighbors"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(drawdown: Drawdown, yarnsim: YarnSim,i:number, j:number) : YarnSim &#x3D;&gt; {

    //there is something else for the western cells to reference
    if(hasWestNeighbor(drawdown, i,j)) return; 

    //unset until you find the next set cell
      for(var ndx &#x3D; j+1; ndx &lt; warps(drawdown); ndx++){
        yarnsim[i][ndx] &#x3D; unsetWest( yarnsim[i][ndx]); 
      if(drawdown[i][ndx].isUp()) return;
    }

    return yarnsim;
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="unsetNorth"></a>
                    <span class="name">
                        <span ><b>unsetNorth</b></span>
                        <a href="#unsetNorth"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell) : YarnCell &#x3D;&gt;{
    return (cell ^ 0b1000);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="unsetPole"></a>
                    <span class="name">
                        <span ><b>unsetPole</b></span>
                        <a href="#unsetPole"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell) : YarnCell &#x3D;&gt; {
    return 0b0000;
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="unsetSouth"></a>
                    <span class="name">
                        <span ><b>unsetSouth</b></span>
                        <a href="#unsetSouth"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell:YarnCell) : YarnCell &#x3D;&gt; {
   return (cell ^ 0b0010);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="unsetWest"></a>
                    <span class="name">
                        <span ><b>unsetWest</b></span>
                        <a href="#unsetWest"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(cell: YarnCell): YarnCell &#x3D;&gt;{
    return (cell ^ 0b0001);
  }</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="unsetWestNeighbors"></a>
                    <span class="name">
                        <span ><b>unsetWestNeighbors</b></span>
                        <a href="#unsetWestNeighbors"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(yarnsim: YarnSim, drawdown: Drawdown, i:number, j:number) : YarnSim &#x3D;&gt; {

    //there is something else for the western cells to reference
    if(hasEastNeighbor(drawdown, i,j)) return; 

    //unset until you find the next set cell
    for(var ndx &#x3D; j-1; ndx &gt;&#x3D; 0; ndx--){
      yarnsim[i][ndx] &#x3D; unsetEast(yarnsim[i][ndx]); 
      if(drawdown[i][ndx].isUp()) return;
    }

    return yarnsim;
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/app/mixer/model/operation/topology.ts</h3>
    <section>
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ConstraintName"></a>
                    <span class="name">
                        <span ><b>ConstraintName</b></span>
                        <a href="#ConstraintName"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
  no_drafts: { input_drafts: &#x27;none&#x27;, input_params: &#x27;req&#x27; }, 
  no_params: { input_drafts: &#x27;req&#x27;, input_params: &#x27;none&#x27; }, 
  drafts_opt: { input_drafts: &#x27;opt&#x27;, input_params: &#x27;req&#x27; }, 
  params_opt: { input_drafts: &#x27;req&#x27;, input_params: &#x27;opt&#x27; }, 
  all_req: {input_drafts: &#x27;req&#x27;, input_params: &#x27;req&#x27; },
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ConstraintOptions"></a>
                    <span class="name">
                        <span ><b>ConstraintOptions</b></span>
                        <a href="#ConstraintOptions"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
  req: &#x27;req&#x27;, 
  opt: &#x27;opt&#x27;, 
  none: &#x27;none&#x27;
} as const</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>OPERATION CONSTRAINT
A Constraint on an Operation classifies it based on its
input requirements (both Drafts and Params).</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="OpFactories"></a>
                    <span class="name">
                        <span ><b>OpFactories</b></span>
                        <a href="#OpFactories"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/object" target="_blank" >object</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
  Seed: makeTopoFactory&lt;Seed&gt;(&quot;seed&quot;),
  Pipe: makeTopoFactory&lt;Pipe&gt;(&quot;pipe&quot;),
  Merge: makeTopoFactory&lt;Merge&gt;(&quot;merge&quot;),
  Branch: makeTopoFactory&lt;Branch&gt;(&quot;merge&quot;),
  Bus: makeTopoFactory&lt;Bus&gt;(&quot;bus&quot;),
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="TopologyName"></a>
                    <span class="name">
                        <span ><b>TopologyName</b></span>
                        <a href="#TopologyName"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
  pipe: &#x27;pipe&#x27;, 
  seed: &#x27;seed&#x27;, 
  merge: &#x27;merge&#x27;, 
  branch: &#x27;branch&#x27;, 
  bus: &#x27;bus&#x27;
} as const</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>OPERATION TOPOLOGY
Topology refers to the shape of the Operation in terms of its
number of input and output Drafts. Classifies Operations.</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
</section>
    <h3>src/app/player/model/playerop.ts</h3>
    <section>
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="defaultPerform"></a>
                    <span class="name">
                        <span ><b>defaultPerform</b></span>
                        <a href="#defaultPerform"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>(init: PlayerState) &#x3D;&gt; { 
  let res &#x3D; copyState(init);
  return Promise.resolve(res);
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>The &quot;do nothing&quot; perform</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="forward"></a>
                    <span class="name">
                        <span ><b>forward</b></span>
                        <a href="#forward"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../interfaces/SingleOpTemplate.html" target="_self" >SingleOpTemplate</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
  id: -1,
  name: &#x27;forward&#x27;,
  classifier: &#x27;prog&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt; [{
    name: &#x27;step size&#x27;,
    dx: &#x27;the number of rows to move forward&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 1,
  }],
  perform: (init: PlayerState) &#x3D;&gt; { 
    let res &#x3D; copyState(init);
    res.row &#x3D; (init.row+1) % wefts(init.draft.drawdown);
    res.pedal &#x3D; &#x27;forward&#x27;;
    if (res.weaving) res.numPicks++;
    return Promise.resolve(res); 
  }
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="refresh"></a>
                    <span class="name">
                        <span ><b>refresh</b></span>
                        <a href="#refresh"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../interfaces/SingleOpTemplate.html" target="_self" >SingleOpTemplate</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
  id: -1,
  name: &#x27;refresh&#x27;,
  classifier: &#x27;prog&#x27;,
  params: [],
  perform: defaultPerform,
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="reverse"></a>
                    <span class="name">
                        <span ><b>reverse</b></span>
                        <a href="#reverse"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../interfaces/SingleOpTemplate.html" target="_self" >SingleOpTemplate</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
  id: -1,
  name: &#x27;reverse&#x27;,
  classifier: &#x27;prog&#x27;,
  params: &lt;Array&lt;NumParam&gt;&gt; [{
    name: &#x27;step size&#x27;,
    dx: &#x27;the number of rows to move backward&#x27;,
    type: &#x27;number&#x27;,
    min: 1,
    max: 100,
    value: 1,
  }],
  perform: (init: PlayerState) &#x3D;&gt; { 
    let res &#x3D; copyState(init);
    res.row &#x3D; (init.row+wefts(init.draft.drawdown)-1) % wefts(init.draft.drawdown);
    res.pedal &#x3D; &#x27;reverse&#x27;;
    if (res.weaving) res.numPicks++;
    return Promise.resolve(res);
  }
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/app/core/model/draft2wif.ts</h3>
    <section>
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="DraftToWIF"></a>
                    <span class="name">
                        <span ><b>DraftToWIF</b></span>
                        <a href="#DraftToWIF"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/object" target="_blank" >object</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    toString: function(draft)  {
        
    },

    introString: function() {
    }
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/app/player/model/dbnodes.ts</h3>
    <section>
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="EMPTY_NODE_ARRAY"></a>
                    <span class="name">
                        <span ><b>EMPTY_NODE_ARRAY</b></span>
                        <a href="#EMPTY_NODE_ARRAY"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>false</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/app/core/model/util.ts</h3>
    <section>
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="utilInstance"></a>
                    <span class="name">
                        <span ><b>utilInstance</b></span>
                        <a href="#utilInstance"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>new Util()</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>



                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'miscellaneous-variables';
            var COMPODOC_CURRENT_PAGE_URL = 'variables.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
